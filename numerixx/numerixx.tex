%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{0}



\title{Numerixx}
\date{Feb 09, 2024}
\release{0.0.1}
\author{Troldal}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxstepscope


\chapter{Introduction}
\label{\detokenize{docIntro:introduction}}\label{\detokenize{docIntro::doc}}
\sphinxAtStartPar
The Numerixx library is a collection of functions and classes for numerical computing. Numerixx was developed in C++, with the purpose of providing implementations of the most common numerical algorithms. It is by no means the purpose to be as feature rich as other numerical libraries, such as the GNU Scientific Library (GSL), nor is it the purpose to be as super\sphinxhyphen{}optimized for performance as other numerical libraries. Rather, the intent is to provide modern C++ implementations of common numerical algorithms, and make them available as a header\sphinxhyphen{}only library, so that it can be integrated easily into client code.

\sphinxAtStartPar
Emphasis have been put on the architecture of the library, so that it is easy to maintain and easy to extend. In many cases, it will be possible for users to use their own custom algorithms, and plug them in to the Numerixx library. Each section will provide guidance for how to extend the library with custom algorithms.

\sphinxAtStartPar
While performance is always a concern, the primary focus of the library is to provide correct and reliable numerical algorithms, with an intuitive interface. Performance is a secondary concern, and the library is not intended to be used for high\sphinxhyphen{}performance computing. So if you intend to implement the next\sphinxhyphen{}generation weather forecast model, you should probably look elsewhere.


\section{License and Warranty}
\label{\detokenize{docIntro:license-and-warranty}}
\sphinxAtStartPar
Numerixx is licensed under the MIT Software License. The MIT Software License is a permissive, open\sphinxhyphen{}source software license that allows users to freely use, modify, distribute, and sublicense the licensed software without any warranty. The library can also be used in commercial closed\sphinxhyphen{}source software; the license only requires that the license and copyright notice be included in any copies or modifications of the software.

\sphinxAtStartPar
Please note, however, that the Numerixx library has no warranty, and is provided “as is”. It is the responsibility of the users to validate the behavior and accuracy of the library.

\sphinxAtStartPar
MIT License

\sphinxAtStartPar
Copyright (c) 2023 Kenneth Troldal Balslev

\sphinxAtStartPar
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the “Software”), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

\sphinxAtStartPar
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

\sphinxAtStartPar
THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

\sphinxstepscope


\chapter{A Word About Error Handling}
\label{\detokenize{docError:a-word-about-error-handling}}\label{\detokenize{docError:error-handling}}\label{\detokenize{docError::doc}}
\sphinxAtStartPar
Error handling in Numerixx is quite simple: there is none!

\sphinxAtStartPar
That may sound strange, as there may be many situations where you would like to handle errors. However, what conditions are considered errors is often a matter of opinion. For example, if you are trying to calculate the square root of a negative number, you may consider that an error. However, in some contexts, it may be perfectly acceptable to return a complex number in that case. In other cases, you may want to return a NaN or raise an exception.

\sphinxAtStartPar
For that reason, Numerixx approaches matters in a different manner. Out of the box, there is no error handling of any kind. However, the library has been designed to be customizable, so you can easily add whatever error handling you want.

\sphinxAtStartPar
Each section of the documentation will provide specific details about how a given function or class can be customized, for example to handle errors. Here follows an example from the section about {\hyperref[\detokenize{docRoots::doc}]{\sphinxcrossref{\DUrole{doc}{one\sphinxhyphen{}dimensional root finding}}}}:

\sphinxAtStartPar
Finding the root of a function using the bisection method can be done like so:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{root}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{fsolve}\PYG{o}{\PYGZlt{}}\PYG{n}{Bisection}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{func}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mf}{2.5}\PYG{+w}{ }\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{.}\PYG{n}{result}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This will use default settings for the accuracy and max. number of iterations. But what should happen if the max. number of iterations are exceeded? In some situations, this may be considered an exceptional conditions, and an exception should be thrown; in other cases, that may be overkill.

\sphinxAtStartPar
To handle this, you can provide a custom “stop token”. This is a functor (such as a lambda), that can be provided as an additional argument to the \sphinxtitleref{fsolve} function. This functor will be called at each iteration, and if it returns true, the iteration will stop. Here is an example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{root}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{fsolve}\PYG{o}{\PYGZlt{}}\PYG{n}{Bisection}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{func}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mf}{2.5}\PYG{+w}{ }\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{state}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{c+cm}{/*number of iterations exceeded*/}\PYG{p}{)}
\PYG{+w}{        }\PYG{k}{throw}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Too many iterations}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{     }\PYG{n}{If}\PYG{p}{(}\PYG{c+cm}{/*required accuracy has been reached*/}\PYG{p}{)}
\PYG{+w}{         }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{true}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{.}\PYG{n}{result}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this example, the lambda will throw an exception if the number of iterations exceeds 100. If you want to handle the error in a different way, you can do so by modifying the lambda accordingly.

\sphinxAtStartPar
As an alternative to providing the token as an argument, it can also be provided as an additional template argument to the \sphinxtitleref{fsolve} function. This can be useful if you want to use the same stop token for many different calls to fsolve. Here is an example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{root}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{fsolve}\PYG{o}{\PYGZlt{}}\PYG{n}{Bisection}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{MyStopToken}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{func}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mf}{2.5}\PYG{+w}{ }\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{.}\PYG{n}{result}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this case, \sphinxtitleref{MyStopToken} is a class that implements the stop token interface. The interface is quite simple, and consists of a single method, which is called at each iteration. The method should return true if the iteration should stop, and false otherwise. The method is passed a reference to the state object, which contains information about the current iteration. The state object is a simple struct, and you can access its members directly.

\sphinxAtStartPar
If throwing an exception is not an option, you can also customize the return type of the fsolve function. By default, it just returns the latest guess of the root, regardless of the reason for stopping. However, you can customize the return type to include additional information, such as the reason for stopping. One option is to use \sphinxtitleref{std::expected} from C++23 (or alternative implementations, such as \sphinxtitleref{tl::expected} from TartanLlama), which allows you to return either a value or an error. Here is an example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{outputter}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{k}{auto}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{data}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{tl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{expected}\PYG{o}{\PYGZlt{}}\PYG{k}{decltype}\PYG{p}{(}\PYG{n}{data}\PYG{p}{.}\PYG{n}{guess}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{auto}\PYG{+w}{ }\PYG{p}{[}\PYG{n}{iter}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{guess}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{previous}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{using}\PYG{+w}{ }\PYG{n}{expected}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{tl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{expected}\PYG{o}{\PYGZlt{}}\PYG{k}{decltype}\PYG{p}{(}\PYG{n}{guess}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{p}{;}

\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{iter}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{tl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{make\PYGZus{}unexpected}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Too many iterations}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{expected}\PYG{p}{(}\PYG{n}{guess}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{root}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{fsolve}\PYG{o}{\PYGZlt{}}\PYG{n}{Bisection}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{func}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mf}{2.5}\PYG{+w}{ }\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{.}\PYG{n}{result}\PYG{p}{(}\PYG{n}{outputter}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxtitleref{outputter} is a functor that takes the state object as input, and returns a \sphinxtitleref{tl::expected} object, that contains either the value or an error. In this case, the outputter will return an error message if the number of iterations exceeds 5. If you want to handle the error in a different way, you can modify the outputter accordingly.

\sphinxAtStartPar
Similar to the stop token, the outputter can also be provided as an additional template argument to the \sphinxtitleref{result} function. This can be useful if you want to use the same outputter for many different calls to \sphinxtitleref{fsolve}. Here is an example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{root}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{fsolve}\PYG{o}{\PYGZlt{}}\PYG{n}{Bisection}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{func}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mf}{2.5}\PYG{+w}{ }\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{.}\PYG{n}{result}\PYG{o}{\PYGZlt{}}\PYG{n}{MyOutputter}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this case, \sphinxtitleref{MyOutputter} is a class that implements the outputter interface.

\sphinxAtStartPar
In summary, error handling in Numerixx is quite simple, but also quite flexible. You can easily customize the error handling to suit your needs, and you can do so in a way that is consistent across the entire library.

\sphinxstepscope


\chapter{Polynomials}
\label{\detokenize{docPolynomial:polynomials}}\label{\detokenize{docPolynomial:id1}}\label{\detokenize{docPolynomial::doc}}
\sphinxAtStartPar
The Polynomial section explores the \sphinxcode{\sphinxupquote{Polynomial}} class. It provides a powerful representation of mathematical polynomials for numerical manipulation and computation. This section will guide you through constructing polynomials, performing basic and advanced operations, handling polynomial\sphinxhyphen{}related errors, and working with real and complex coefficients. Declarations can be found in \sphinxcode{\sphinxupquote{poly/Poly.hpp}}.


\section{Overview}
\label{\detokenize{docPolynomial:overview}}
\sphinxAtStartPar
A polynomial is a mathematical expression that consists of variables, coefficients, and exponents. It is a function that can be written in the form of an equation where the variables are raised to non\sphinxhyphen{}negative integer powers, and the coefficients are real numbers. In general, a polynomial can have one or more variables, and its degree is the highest power of the variable in the expression.

\sphinxAtStartPar
For example, the expression \(3x^2 - 2x + 1\) is a polynomial in one variable, x, with degree 2. The coefficient of \(x^2\) is 3, the coefficient of \(x\) is \sphinxhyphen{}2, and the constant term is 1. The degree of this polynomial is 2, which means that the highest power of \(x\) in the expression is 2.

\sphinxAtStartPar
Polynomials are a fundamental concept in mathematics and have many important applications in various fields, such as engineering, physics, computer science, and economics. They are used to model real\sphinxhyphen{}world problems, approximate complex functions, and solve equations.

\sphinxAtStartPar
One of the most important properties of polynomials is that they are closed under addition, subtraction, and multiplication. This means that if two polynomials are added, subtracted, or multiplied, the result is always another polynomial. For example, if we add the polynomials \(2x^3 + 3x^2 + 5x + 7\) and \(x^3 - 2x^2 + 4x - 3\), we get the polynomial \(3x^3 + x^2 + 9x + 4\). This property makes polynomials easy to work with and manipulate algebraically.

\sphinxAtStartPar
Another important property of polynomials is that they have roots or zeros, which are the values of the variable that make the polynomial equal to zero. The number of roots of a polynomial is equal to its degree, and each root corresponds to a linear factor of the polynomial. For example, the polynomial \(3x^2 - 2x + 1\) has two roots, which correspond to the linear factors \((x - \frac{2 + \sqrt{2}}{6})\) and \((x - \frac{2 - \sqrt{2}}{6})\).

\sphinxAtStartPar
Polynomials also have a unique factorization property, which means that every polynomial can be factored into a product of irreducible polynomials. An irreducible polynomial is a polynomial that cannot be factored into two or more polynomials of lower degree. For example, the polynomial \(x^2 + 1\) is irreducible over the real numbers, but it can be factored into the product of the two linear factors \((x + i)\) and \((x - i)\) over the complex numbers.


\section{Quick Start}
\label{\detokenize{docPolynomial:quick-start}}
\sphinxstepscope


\chapter{Numerical Derivatives}
\label{\detokenize{docDerivative:numerical-derivatives}}\label{\detokenize{docDerivative::doc}}
\sphinxAtStartPar
This sections describes classes and functions for finding derivatives of arbitrary one\sphinxhyphen{}dimensional functions. Functions for computing numerical derivatives can be found in \sphinxcode{\sphinxupquote{calculus/Derivatives.hpp}}.


\section{Overview}
\label{\detokenize{docDerivative:overview}}
\sphinxAtStartPar
Numerical derivatives are a numerical approximation of the derivative of a function. The derivative of a function represents the rate at which the function changes with respect to its independent variable. It is often useful in science and engineering to know the derivative of a function at a particular point, as it provides information about the function’s behavior in the vicinity of that point.

\sphinxAtStartPar
There are several methods to compute numerical derivatives, but the most common ones are the forward difference, backward difference, and central difference methods.

\sphinxAtStartPar
The forward difference method involves computing the slope of a secant line between two points on the function, one slightly to the right of the point of interest, and one at the point of interest. The slope of this line approximates the derivative of the function at the point of interest, and can be computed as:

\sphinxAtStartPar
\(f'(x) ≈ \frac{f(x + h) - f(x)}{h}\)

\sphinxAtStartPar
where h is a small positive number that determines the distance between the two points.

\sphinxAtStartPar
Similarly, the backward difference method involves computing the slope of a secant line between two points on the function, one slightly to the left of the point of interest, and one at the point of interest. The slope of this line approximates the derivative of the function at the point of interest, and can be computed as:

\sphinxAtStartPar
\(f'(x) ≈ \frac{f(x) - f(x - h)}{h}\)

\sphinxAtStartPar
Finally, the central difference method involves computing the slope of a secant line between two points on the function, one slightly to the right of the point of interest, and one slightly to the left of the point of interest. The slope of this line approximates the derivative of the function at the point of interest, and can be computed as:

\sphinxAtStartPar
\(f'(x) ≈ \frac{f(x + h) - f(x - h)}{2h}\)

\sphinxAtStartPar
where h is a small positive number that determines the distance between the two points.

\sphinxAtStartPar
These numerical methods are called “approximations” because they introduce some error compared to the exact derivative of the function. However, the error can be made arbitrarily small by decreasing the value of h, but this leads to increased numerical instability and rounding errors in the computation. Guidance for choosing the step size (h) is given by Press et al. %
\begin{footnote}[1]\sphinxAtStartFootnote
William H. Press et al. (2007). Numerical Recipes, 3rd Edition.
%
\end{footnote}.

\sphinxAtStartPar
Typically, central difference methods yield the best results because they evaluate the function symetrically around the point where the derivative is to be found. However, the forward and backward methods are useful in cases where the function can only be evaluated in one direction. An example of this is the function \(f(x) = \sqrt{x}\). Evaluation of the derivative at the point \(0.0\) can only be done using  forward difference methods, as central and backward difference methods would require function evaluations at negative values, which would yield results in the complex domain for this particular function.


\section{Quick Start}
\label{\detokenize{docDerivative:quick-start}}
\sphinxAtStartPar
The simplest way to compute the derivative of a function is to use one of the convenience functions in the \sphinxcode{\sphinxupquote{nxx::deriv}} namespace, i.e. the \sphinxcode{\sphinxupquote{central}}, \sphinxcode{\sphinxupquote{forward}}, or \sphinxcode{\sphinxupquote{backward}} functions. These functions will compute the 1st derivative of a function, using (unsurprisingly) central difference, forward difference, and backward difference methods. Internally, these functions use Richardson extrapolation to compute the derivatives.

\sphinxAtStartPar
All of the functions will return an \sphinxcode{\sphinxupquote{tl::expected}} (or \sphinxcode{\sphinxupquote{std::expected}} when C++23 is in widespread use) which will contain the the result or an \sphinxcode{\sphinxupquote{DerivativeError}} object in case of an error. For further details, please see the {\hyperref[\detokenize{docError:error-handling}]{\sphinxcrossref{\DUrole{std,std-ref}{A Word About Error Handling}}}} section.

\sphinxAtStartPar
The following example shows how to find the derivative of the function \(f(x) = ln(x) + 2x\) at the value \(e\), using the \sphinxcode{\sphinxupquote{central}} function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}numbers\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}calculus/Derivatives.hpp\PYGZgt{}}

\PYG{k}{using}\PYG{+w}{ }\PYG{n}{nxx}\PYG{o}{:}\PYG{o}{:}\PYG{n}{deriv}\PYG{o}{:}\PYG{o}{:}\PYG{n}{central}\PYG{p}{;}
\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{func}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{log}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{;}\PYG{+w}{ }\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{central}\PYG{p}{(}\PYG{n}{func}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{numbers}\PYG{o}{:}\PYG{o}{:}\PYG{n}{e}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
In the above code example, the function is provided as a lambda. However, any callable object can be used, as long as it takes a single floating point argument, and returns a floating point value. The \sphinxcode{\sphinxupquote{forward}} and \sphinxcode{\sphinxupquote{backward}} functions works in an identical manner.

\sphinxAtStartPar
The API for using the \sphinxcode{\sphinxupquote{central}}, \sphinxcode{\sphinxupquote{forward}}, or \sphinxcode{\sphinxupquote{backward}} functions is given below.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
doxygenfunction: Unable to find project ‘Numerixx’ in breathe\_projects dictionary
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
doxygenfunction: Unable to find project ‘Numerixx’ in breathe\_projects dictionary
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
doxygenfunction: Unable to find project ‘Numerixx’ in breathe\_projects dictionary
\end{sphinxadmonition}


\section{Advanced Use}
\label{\detokenize{docDerivative:advanced-use}}

\subsection{Algorithms}
\label{\detokenize{docDerivative:algorithms}}
\sphinxAtStartPar
In case more fine\sphinxhyphen{}grained usage is required, the \sphinxcode{\sphinxupquote{derivative\textless{}\textgreater{}}} template function can be used. The \sphinxcode{\sphinxupquote{derivative\textless{}\textgreater{}}} function has the same signature as the convenience functions described above. However, in addition it also takes a single template argument with the type of the algorithm used to compute the derivative.

\sphinxAtStartPar
The following example shows how to use the function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}numbers\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}calculus/Derivatives.hpp\PYGZgt{}}

\PYG{k}{using}\PYG{+w}{ }\PYG{n}{nxx}\PYG{o}{:}\PYG{o}{:}\PYG{n}{deriv}\PYG{o}{:}\PYG{o}{:}\PYG{n}{central}\PYG{p}{;}
\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{func}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{log}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{;}\PYG{+w}{ }\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{derivative}\PYG{o}{\PYGZlt{}}\PYG{n}{Order1CentralRichardson}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{func}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{numbers}\PYG{o}{:}\PYG{o}{:}\PYG{n}{e}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
In the example above, the \sphinxcode{\sphinxupquote{derivative\textless{}\textgreater{}}} function is passed the \sphinxcode{\sphinxupquote{Order1CentralRichardson}} type as the algorithm type. This is one of several algorithms that comes bundled with the Numerixx library. The following is a list of algorithms for computing the 1st derivatives:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Order1CentralRichardson}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Order1Central3Point}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Order1Central5Point}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Order1ForwardRichardson}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Order1Forward2Point}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Order1Forward3Point}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Order1BackwardRichardson}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Order1Backward2Point}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Order1Backward3Point}}

\end{itemize}

\sphinxAtStartPar
In addition, the following algorithms can be used for computation of the 2nd derivatives:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Order2Central3Point}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Order2Central5Point}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Order2Forward3Point}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Order2Forward4Point}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Order2Backward3Point}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Order2Backward4Point}}

\end{itemize}

\sphinxAtStartPar
Descriptions of the algorithms listed above can be found in the references %
\begin{footnote}[2]\sphinxAtStartFootnote
Richard L. Burden et al. (2011). Numerical Analysis, 9th Edition.
%
\end{footnote} %
\begin{footnote}[3]\sphinxAtStartFootnote
Steven C. Chapra et al. (2021). Numerical Methods for Engineers, 8th Edition.
%
\end{footnote} %
\begin{footnote}[4]\sphinxAtStartFootnote
Sauer, T. (2012). Numerical Analysis, 2nd Edition.
%
\end{footnote} %
\begin{footnote}[5]\sphinxAtStartFootnote
Ward Cheney et al. (2008). Numerical Mathematics and Computing, 6th Edition.
%
\end{footnote}.

\sphinxAtStartPar
In general, the algorithms with 3\sphinxhyphen{}5 function evaluations and the Richardson extrapolation algorithms provide the highest accuracy. One might think that more function evaluations would require more CPU time, but it turns out not to be significant. The following table shows benchmarks of the different algorithms, and it can be seen that the choice of algorithm does not significantly affect the computation time.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{n}{Benchmark}                            \PYG{n}{Time}             \PYG{n}{CPU}   \PYG{n}{Iterations}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{n}{BM\PYGZus{}Order1CentralRichardson}       \PYG{l+m+mf}{0.239} \PYG{n}{ns}        \PYG{l+m+mf}{0.239} \PYG{n}{ns}   \PYG{l+m+mi}{1000000000}
\PYG{n}{BM\PYGZus{}Order1Central3Point}           \PYG{l+m+mf}{0.237} \PYG{n}{ns}        \PYG{l+m+mf}{0.237} \PYG{n}{ns}   \PYG{l+m+mi}{1000000000}
\PYG{n}{BM\PYGZus{}Order1Central5Point}           \PYG{l+m+mf}{0.232} \PYG{n}{ns}        \PYG{l+m+mf}{0.232} \PYG{n}{ns}   \PYG{l+m+mi}{1000000000}
\PYG{n}{BM\PYGZus{}Order1ForwardRichardson}       \PYG{l+m+mf}{0.231} \PYG{n}{ns}        \PYG{l+m+mf}{0.231} \PYG{n}{ns}   \PYG{l+m+mi}{1000000000}
\PYG{n}{BM\PYGZus{}Order1Forward2Point}           \PYG{l+m+mf}{0.232} \PYG{n}{ns}        \PYG{l+m+mf}{0.232} \PYG{n}{ns}   \PYG{l+m+mi}{1000000000}
\PYG{n}{BM\PYGZus{}Order1Forward3Point}           \PYG{l+m+mf}{0.229} \PYG{n}{ns}        \PYG{l+m+mf}{0.229} \PYG{n}{ns}   \PYG{l+m+mi}{1000000000}
\PYG{n}{BM\PYGZus{}Order1BackwardRichardson}      \PYG{l+m+mf}{0.230} \PYG{n}{ns}        \PYG{l+m+mf}{0.230} \PYG{n}{ns}   \PYG{l+m+mi}{1000000000}
\PYG{n}{BM\PYGZus{}Order1Backward2Point}          \PYG{l+m+mf}{0.231} \PYG{n}{ns}        \PYG{l+m+mf}{0.231} \PYG{n}{ns}   \PYG{l+m+mi}{1000000000}
\PYG{n}{BM\PYGZus{}Order1Backward3Point}          \PYG{l+m+mf}{0.230} \PYG{n}{ns}        \PYG{l+m+mf}{0.230} \PYG{n}{ns}   \PYG{l+m+mi}{1000000000}
\end{sphinxVerbatim}

\sphinxAtStartPar
The algorithms for computing 2nd derivatives have similar performance characteristics.

\sphinxAtStartPar
In addition to the bundled algorithms, it is also possible to provide a custom algorithm, as long as it conforms to the correct interface. Any callable object which takes as arguments a single\sphinxhyphen{}variable function, a floating point value and a floating point step size, and that returns a floating point result (essentially the same interface as the \sphinxcode{\sphinxupquote{derivative\textless{}\textgreater{}}} function) can be used. The following example shows how to supply a custom algorithm in the form of a lambda:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}numbers\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}calculus/Derivatives.hpp\PYGZgt{}}

\PYG{k}{using}\PYG{+w}{ }\PYG{n}{nxx}\PYG{o}{:}\PYG{o}{:}\PYG{n}{deriv}\PYG{o}{:}\PYG{o}{:}\PYG{n}{central}\PYG{p}{;}
\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{algo}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{function}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{stepsize}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{function}\PYG{p}{(}\PYG{n}{val}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{stepsize}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{function}\PYG{p}{(}\PYG{n}{val}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{stepsize}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{/}\PYG{+w}{ }\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{stepsize}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{func}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{log}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{;}\PYG{+w}{ }\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{derivative}\PYG{o}{\PYGZlt{}}\PYG{k}{decltype}\PYG{p}{(}\PYG{n}{algo}\PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{func}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{numbers}\PYG{o}{:}\PYG{o}{:}\PYG{n}{e}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The API for using the \sphinxcode{\sphinxupquote{diff\textless{}\textgreater{}}} function is given below.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
doxygenfunction: Unable to find project ‘Numerixx’ in breathe\_projects dictionary
\end{sphinxadmonition}


\subsection{Derivative FUNC\_T Objects}
\label{\detokenize{docDerivative:derivative-func-t-objects}}
\sphinxAtStartPar
The functions and algorithms described above can of course be wrapped in a function object representing the derivative
of the function in question. However, Numerixx provides a convenience function for creating function objects like this
automatically.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{derivativeOf\textless{}\textgreater{}}} template function can be used to create a function object representing the derivative of
any input function, provided it has the correct interface. The function uses the \sphinxcode{\sphinxupquote{Order1CentralRichardson}}
algorithm by default, but other algorithms can be specified manually.

\sphinxAtStartPar
The following code illustrates how to use it:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}numbers\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}calculus/Derivatives.hpp\PYGZgt{}}

\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{nxx}\PYG{o}{:}\PYG{o}{:}\PYG{n+nn}{deriv}\PYG{p}{;}
\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{func}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{log}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{;}\PYG{+w}{ }\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{d1func}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{derivativeOf}\PYG{p}{(}\PYG{n}{func}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{d2func}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{derivativeOf}\PYG{o}{\PYGZlt{}}\PYG{n}{Order2Central5Point}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{func}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{d1func\PYGZus{}val}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{d1func}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{numbers}\PYG{o}{:}\PYG{o}{:}\PYG{n}{e}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{d2func\PYGZus{}val}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{d2func}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{numbers}\PYG{o}{:}\PYG{o}{:}\PYG{n}{e}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
For objects of the \sphinxcode{\sphinxupquote{Polynomial}} class, a separate \sphinxcode{\sphinxupquote{derivativeOf\textless{}\textgreater{}}} function is defined in the
\sphinxcode{\sphinxupquote{nxx::poly}} namespace. This function will create a function object that will compute the derivative
analytically, rather than numerically. See the {\hyperref[\detokenize{docPolynomial:polynomials}]{\sphinxcrossref{\DUrole{std,std-ref}{Polynomials}}}} section for details.
\end{sphinxadmonition}

\sphinxAtStartPar
The API for using the \sphinxcode{\sphinxupquote{derivativeOf\textless{}\textgreater{}}} function is given below.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
doxygenfunction: Unable to find project ‘Numerixx’ in breathe\_projects dictionary
\end{sphinxadmonition}

\sphinxstepscope


\chapter{One\sphinxhyphen{}Dimensional Root\sphinxhyphen{}Finding}
\label{\detokenize{docRoots:one-dimensional-root-finding}}\label{\detokenize{docRoots::doc}}
\sphinxAtStartPar
This section delves into a range of classes and functions dedicated to the finding roots in one\sphinxhyphen{}dimensional functions. The featured algorithms are divided into two main types: bracketing algorithms, which operate without the need for function derivatives, and polishing algorithms, which require the computation of the function’s derivative. In addition, the library offers search algorithms that can be used to find a bracket where a root exists when the initial guess is not near the actual root.

\sphinxAtStartPar
All functions are available through the \sphinxcode{\sphinxupquote{Roots.hpp}} header file.


\section{Overview}
\label{\detokenize{docRoots:overview}}
\sphinxAtStartPar
Popular one\sphinxhyphen{}dimensional root\sphinxhyphen{}finding methods encompass the bisection method, Newton’s method, Ridder’s method, and the secant method. Each of these methods brings its unique advantages and potential drawbacks, and their applicability hinges on the nature of the problem at hand.

\sphinxAtStartPar
Bracketing methods such as the bisection method and Ridder’s method are designed to locate a root within a specified interval. These methods are particularly useful when the function’s derivative is unavailable or when the function is not differentiable. The bisection method, in particular, is known for its simplicity and reliability, as it guarantees convergence to a root as long as the function is continuous and changes sign within the interval. Ridder’s method, on the other hand, can converge with fewer iterations, but each iteration is more computationally expensive.

\sphinxAtStartPar
The following bracketing methods are available in the library:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Bisection Method}: Known for its reliability and surefire convergence, the bisection method is a good choice when you need a method that is guaranteed to find a root. However, it can sometimes converge at a slower pace compared to other methods. (Wikipedia: \sphinxhref{https://en.wikipedia.org/wiki/Bisection\_method}{Bisection Method})

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Ridder’s Method}: Outpacing the bisection method, Ridder’s method can converge more rapidly. However, each iteration is more computationally expensive, and the function must have a continuous second derivative. (Wikipedia: \sphinxhref{https://en.wikipedia.org/wiki/Ridder\%27s\_method}{Ridder’s Method})

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Regula Falsi Method}: Also known as the false position method, the regula falsi method is a bracketing algorithm that uses linear interpolation to find the root of a function. It is similar to the bisection method, but it can converge faster in some cases. (Wikipedia: \sphinxhref{https://en.wikipedia.org/wiki/Regula\_falsi}{Regula Falsi Method})

\end{itemize}

\sphinxAtStartPar
Polishing methods, such as Newton’s method and Steffensen’s method, are designed to refine an initial guess to find a root. These methods are generally faster than bracketing methods, but they require the first derivative of the function to be available. Newton’s method, in particular, is known for its speed and efficiency, but it may fail to converge or converge to a local minimum instead of a root.

\sphinxAtStartPar
The following polishing methods are available in the library:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Newton’s Method}: A popular root\sphinxhyphen{}finding algorithm, Newton’s method is known for its speed and efficiency. However, it requires the function to be differentiable and the derivative to be non\sphinxhyphen{}zero at the estimate. (Wikipedia: \sphinxhref{https://en.wikipedia.org/wiki/Newton\%27s\_method}{Newton’s Method})

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Secant Method}: The secant method is a root\sphinxhyphen{}finding algorithm that does not require the derivative of the function. It is similar to the Newton\sphinxhyphen{}Raphson method, but it uses a finite difference approximation to the derivative. (Wikipedia: \sphinxhref{https://en.wikipedia.org/wiki/Secant\_method}{Secant Method})

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Steffensen’s Method}: Steffensen’s method is an iterative root\sphinxhyphen{}finding algorithm that improves upon the simple fixed\sphinxhyphen{}point iteration by incorporating a form of Aitken’s Δ\(\sp{\text{2}}\) process. This method is particularly effective for functions where the derivative is difficult to compute or is not readily available. (Wikipedia: \sphinxhref{https://en.wikipedia.org/wiki/Steffensen\%27s\_method}{Steffensen’s Method})

\end{itemize}

\sphinxAtStartPar
Search methods, such as BracketSearchUp and BracketSearchDown, are designed to incrementally expand or subdivide the search bounds to find a bracket where a root exists. These methods are useful when the initial guess is not near the actual root.

\sphinxAtStartPar
The following search methods are available in the library:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{BracketSearchUp}: A specialized search algorithm designed to incrementally expand the search bounds upwards (increasing values) to find a bracket where a root exists.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{BracketSearchDown}: A specialized search algorithm designed to incrementally expand the search bounds downwards (decreasing values) to find a bracket where a root exists.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{BracketExpandUp}: A specialized search algorithm designed to incrementally expand the upper bound upwards (increasing values) while keeping the lower bound fixed. This is useful for finding a bracket where a root exists when the initial guess is lower than the actual root.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{BracketExpandDown}: A specialized search algorithm designed to incrementally expand the lower bound downwards (decreasing values) while keeping the upper bound fixed. This is useful for finding a bracket where a root exists when the initial guess is higher than the actual root.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{BracketExpandOut}: A specialized search algorithm designed to incrementally expand both the lower and upper bounds symmetrically outwards. This is useful for finding a bracket where a root exists when the initial guess is not near the actual root.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{BracketSubdivide}: A specialized search algorithm designed to subdivide the current search bounds into smaller segments in an attempt to find a bracket where a root exists.

\end{itemize}

\sphinxAtStartPar
Using these methods should be done through the \sphinxcode{\sphinxupquote{fsolve}}, \sphinxcode{\sphinxupquote{fdfsolve}}, and \sphinxcode{\sphinxupquote{search}} functions, which are designed to be easy to use and provide a consistent interface for all the solvers.


\section{Important Considerations}
\label{\detokenize{docRoots:important-considerations}}
\sphinxAtStartPar
It’s imperative to recognize that root\sphinxhyphen{}finding functions are designed to locate a single root at any given instance. In cases where multiple roots are present within the search range, the function will identify and return the initial root it encounters. Pinpointing which root will be found in a region with several roots is generally unpredictable. Notably, attempting to find a root in such areas usually doesn’t trigger any error messages, despite the inherent challenges.


\section{Quick Start}
\label{\detokenize{docRoots:quick-start}}
\sphinxAtStartPar
The library provides the following functions for finding roots in one\sphinxhyphen{}dimensional functions:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{fsolve}: A function for finding a root of a one\sphinxhyphen{}dimensional function using a bracketing method. It takes a bracketing method object and an initial bracket around the root to be found.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{fdfsolve}: A function for finding a root of a one\sphinxhyphen{}dimensional function using a polishing method. It takes a polishing method object and an initial guess for the root.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{search}: A function for finding a bracket where a root exists when the initial guess is not near the actual root. It takes a search method object and an initial guess for the root.

\end{itemize}

\sphinxAtStartPar
These functions return a proxy object that contains the result of the root\sphinxhyphen{}finding process. The result can be accessed using the \sphinxcode{\sphinxupquote{result}} member function, which returns the estimated root.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The proxy objects returned by the root\sphinxhyphen{}finding functions are not intended to be stored or passed around. They are designed to be used immediately to access the result of the root\sphinxhyphen{}finding process. Consequently, they cannot be copied or moved, and the member functions are only available for r\sphinxhyphen{}value references.
\end{sphinxadmonition}

\sphinxAtStartPar
The following example shows how to find the root of the function \(f(x) = x^2 - 5\) (defined as a lambda) using a bracketing method:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n}{nxx}\PYG{o}{:}\PYG{o}{:}\PYG{n}{roots}\PYG{o}{:}\PYG{o}{:}\PYG{n}{fsolve}\PYG{p}{;}
\PYG{k}{using}\PYG{+w}{ }\PYG{n}{nxx}\PYG{o}{:}\PYG{o}{:}\PYG{n}{roots}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Bisection}\PYG{p}{;}
\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{fsolve}\PYG{o}{\PYGZlt{}}\PYG{n}{Bisection}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k}{return}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mf}{2.5}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{.}\PYG{n}{result}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Similarly, the same function can be solved using Newton’s method (with the derivative being \(f'(x) = 2x\))

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n}{nxx}\PYG{o}{:}\PYG{o}{:}\PYG{n}{roots}\PYG{o}{:}\PYG{o}{:}\PYG{n}{fdfsolve}\PYG{p}{;}
\PYG{k}{using}\PYG{+w}{ }\PYG{n}{nxx}\PYG{o}{:}\PYG{o}{:}\PYG{n}{roots}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Newton}\PYG{p}{;}
\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{fdfsolve}\PYG{o}{\PYGZlt{}}\PYG{n}{Newton}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k}{return}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{+w}{                               }\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mf}{1.25}\PYG{p}{)}\PYG{p}{.}\PYG{n}{result}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The derivative is not required to be provided, as it will be computed numerically using a finite difference approximation. However, this can be less accurate and less efficient than providing the derivative directly.
\end{sphinxadmonition}

\sphinxAtStartPar
Finally, the following example shows how to find a bracket where a root exists when the initial guess is not near the actual root:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n}{nxx}\PYG{o}{:}\PYG{o}{:}\PYG{n}{roots}\PYG{o}{:}\PYG{o}{:}\PYG{n}{search}\PYG{p}{;}
\PYG{k}{using}\PYG{+w}{ }\PYG{n}{nxx}\PYG{o}{:}\PYG{o}{:}\PYG{n}{roots}\PYG{o}{:}\PYG{o}{:}\PYG{n}{BracketSearchUp}\PYG{p}{;}
\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{search}\PYG{o}{\PYGZlt{}}\PYG{n}{BracketSearchUp}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k}{return}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mf}{1.0}\PYG{+w}{ }\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{.}\PYG{n}{result}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
In addition to the arguments provided in the examples above, the root\sphinxhyphen{}finding functions also take two optional arguments for terminating the iterations, namely the relative error (epsilon) and the maximum number of iterations. Those arguments can be provided in any order; the only requirement is that epsilon must be a floating\sphinxhyphen{}point number and the maximum number of iterations must be an integer.

\sphinxAtStartPar
As can be seen from the previous examples, the root\sphinxhyphen{}finding solvers can be invoked in a single line of code, which makes them very easy to use.


\section{Advanced Usage}
\label{\detokenize{docRoots:advanced-usage}}
\sphinxAtStartPar
Although using the root\sphinxhyphen{}finding functions and algorithms can be as simple as shown in the previous examples, there are a number of advanced features and considerations that can be useful in more complex scenarios.


\subsection{Customizing the Solvers}
\label{\detokenize{docRoots:customizing-the-solvers}}
\sphinxAtStartPar
In many cases, the default settings of the solvers will be sufficient. However, in some cases it may be required to provide more fine\sphinxhyphen{}grained control over the solvers and the criteria for terminating the iterations. This can be done by creating a “stop token” object and passing it to the solver.

\sphinxAtStartPar
A stop token is an object that provides a way to stop the iterations of the solver based on a set of criteria. It can be any callable object, such as a lambda, that takes the solver’s state as an argument and returns a boolean value indicating whether the iterations should continue or stop. The stop token can be used to check for convergence, reach a maximum number of iterations, or any other condition that should stop the iterations.

\sphinxAtStartPar
The following example shows how to create a custom stop token and use it with the \sphinxcode{\sphinxupquote{fsolve}} function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n}{nxx}\PYG{o}{:}\PYG{o}{:}\PYG{n}{roots}\PYG{o}{:}\PYG{o}{:}\PYG{n}{fsolve}\PYG{p}{;}
\PYG{k}{using}\PYG{+w}{ }\PYG{n}{nxx}\PYG{o}{:}\PYG{o}{:}\PYG{n}{roots}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Bisection}\PYG{p}{;}
\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{stop\PYGZus{}token}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{solver}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{solver}\PYG{p}{.}\PYG{n}{iter}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{100}\PYG{p}{;}\PYG{+w}{ }\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{fsolve}\PYG{o}{\PYGZlt{}}\PYG{n}{Bisection}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k}{return}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mf}{2.5}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{stop\PYGZus{}token}\PYG{p}{)}\PYG{p}{.}\PYG{n}{result}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this example, the stop token is a lambda that checks whether the number of iterations has reached 100. If the condition is met, the iterations will stop and the result will be returned.

\sphinxAtStartPar
As an alternative to providing the stop token as a function argument, it can also be provided as a second template argument, after the solver algorithm. This can be useful when the stop token is a complex type or when it needs to be reused with multiple solvers:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n}{nxx}\PYG{o}{:}\PYG{o}{:}\PYG{n}{roots}\PYG{o}{:}\PYG{o}{:}\PYG{n}{fsolve}\PYG{p}{;}
\PYG{k}{using}\PYG{+w}{ }\PYG{n}{nxx}\PYG{o}{:}\PYG{o}{:}\PYG{n}{roots}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Bisection}\PYG{p}{;}
\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{stop\PYGZus{}token}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{solver}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{solver}\PYG{p}{.}\PYG{n}{iter}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{100}\PYG{p}{;}\PYG{+w}{ }\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k}{using}\PYG{+w}{ }\PYG{n}{StopToken}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{decltype}\PYG{p}{(}\PYG{n}{stop\PYGZus{}token}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{fsolve}\PYG{o}{\PYGZlt{}}\PYG{n}{Bisection}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{StopToken}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k}{return}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mf}{2.5}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{.}\PYG{n}{result}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Both syntaxes are equivalent, so which one to use is a matter of taste.

\sphinxAtStartPar
However, determining when to terminate the iterations is not the only use of the stop token object; it can also be used to provide additional information about the iterations, such as the number of iterations that have been performed. This can be useful for logging or debugging purposes:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n}{nxx}\PYG{o}{:}\PYG{o}{:}\PYG{n}{roots}\PYG{o}{:}\PYG{o}{:}\PYG{n}{fsolve}\PYG{p}{;}
\PYG{k}{using}\PYG{+w}{ }\PYG{n}{nxx}\PYG{o}{:}\PYG{o}{:}\PYG{n}{roots}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Bisection}\PYG{p}{;}
\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{stop\PYGZus{}token}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{solver}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Iteration: }\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{solver}\PYG{p}{.}\PYG{n}{iter}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ | }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Guess:     }\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{solver}\PYG{p}{.}\PYG{n}{guess}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{solver}\PYG{p}{.}\PYG{n}{iter}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{100}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{;}\PYG{+w}{ }\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{fsolve}\PYG{o}{\PYGZlt{}}\PYG{n}{Bisection}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k}{return}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mf}{2.5}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{stop\PYGZus{}token}\PYG{p}{)}\PYG{p}{.}\PYG{n}{result}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This example shows how the stop token can be used to print the iteration number and the current guess at each iteration. This can be useful for understanding how the solver is converging and for diagnosing any issues that may arise. The output can be redirected to a file or a log for further analysis.

\sphinxAtStartPar
Finally, a stop token can also be used to deal with errors. For example, if reaching the maximum number of iterations is considered an error, the stop token can be used to throw an exception when the condition is met. Or if the current guess of the root is NaN or infinite, the stop token can be used to throw an exception as well:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n}{nxx}\PYG{o}{:}\PYG{o}{:}\PYG{n}{roots}\PYG{o}{:}\PYG{o}{:}\PYG{n}{fsolve}\PYG{p}{;}
\PYG{k}{using}\PYG{+w}{ }\PYG{n}{nxx}\PYG{o}{:}\PYG{o}{:}\PYG{n}{roots}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Bisection}\PYG{p}{;}
\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{stop\PYGZus{}token}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{solver}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{solver}\PYG{p}{.}\PYG{n}{iter}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{throw}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Maximum number of iterations reached}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{isnan}\PYG{p}{(}\PYG{n}{solver}\PYG{p}{.}\PYG{n}{guess}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{|}\PYG{o}{|}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{isinf}\PYG{p}{(}\PYG{n}{solver}\PYG{p}{.}\PYG{n}{guess}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{throw}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{runtime\PYGZus{}error}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Invalid root}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{;}\PYG{+w}{ }\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{fsolve}\PYG{o}{\PYGZlt{}}\PYG{n}{Bisection}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k}{return}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mf}{2.5}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{stop\PYGZus{}token}\PYG{p}{)}\PYG{p}{.}\PYG{n}{result}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
As the previous examples show, the stop token can be used to provide fine\sphinxhyphen{}grained control over the solvers and the criteria for terminating the iterations. This can be useful in a wide range of scenarios, from simple cases where the default settings are sufficient to complex cases where more control is needed.


\subsection{Customizing the Output}
\label{\detokenize{docRoots:customizing-the-output}}
\sphinxAtStartPar
In addition to customizing the solvers, it is also possible to customize the output of the root\sphinxhyphen{}finding functions. As mentioned earlier, the solver functions return a proxy object that contains the result of the root\sphinxhyphen{}finding process. This proxy object can be used to access the final result of the root\sphinxhyphen{}finding, using the \sphinxcode{\sphinxupquote{result}} member function.

\sphinxAtStartPar
In some cases, however, it may be useful to access additional information about the result, or to get the result in a different format. In the simplest form, a type that can be constructed from a floating point number, can be passed as a template argument to the \sphinxcode{\sphinxupquote{result}} function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n}{nxx}\PYG{o}{:}\PYG{o}{:}\PYG{n}{roots}\PYG{o}{:}\PYG{o}{:}\PYG{n}{fsolve}\PYG{p}{;}
\PYG{k}{using}\PYG{+w}{ }\PYG{n}{nxx}\PYG{o}{:}\PYG{o}{:}\PYG{n}{roots}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Bisection}\PYG{p}{;}
\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{fsolve}\PYG{o}{\PYGZlt{}}\PYG{n}{Bisection}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k}{return}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mf}{2.5}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{.}\PYG{n}{result}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
In more complex scenarios, a callable object, such as a lambda, can be passed as an argument. This can be usefule in situations where some error condition need to be reported, but where throwing an exception is not appropriate. This could be the C++23 std::expected type, or one of the alternatives such as tl::expected from TartanLlama:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n}{nxx}\PYG{o}{:}\PYG{o}{:}\PYG{n}{roots}\PYG{o}{:}\PYG{o}{:}\PYG{n}{fsolve}\PYG{p}{;}
\PYG{k}{using}\PYG{+w}{ }\PYG{n}{nxx}\PYG{o}{:}\PYG{o}{:}\PYG{n}{roots}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Bisection}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{outputter}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{k}{auto}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{data}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{tl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{expected}\PYG{o}{\PYGZlt{}}\PYG{k}{decltype}\PYG{p}{(}\PYG{n}{data}\PYG{p}{.}\PYG{n}{guess}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{auto}\PYG{+w}{ }\PYG{p}{[}\PYG{n}{iter}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{guess}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{previous}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{using}\PYG{+w}{ }\PYG{n}{expected}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{tl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{expected}\PYG{o}{\PYGZlt{}}\PYG{k}{decltype}\PYG{p}{(}\PYG{n}{guess}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{p}{;}

\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{iter}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{tl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{make\PYGZus{}unexpected}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Too many iterations}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{expected}\PYG{p}{(}\PYG{n}{guess}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{fsolve}\PYG{o}{\PYGZlt{}}\PYG{n}{Bisection}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k}{return}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mf}{2.5}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{.}\PYG{n}{result}\PYG{p}{(}\PYG{n}{outputter}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The outputter can also be provided as a template argument. The functioanlity is the same,  so which one to use is a matter of taste:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using}\PYG{+w}{ }\PYG{n}{nxx}\PYG{o}{:}\PYG{o}{:}\PYG{n}{roots}\PYG{o}{:}\PYG{o}{:}\PYG{n}{fsolve}\PYG{p}{;}
\PYG{k}{using}\PYG{+w}{ }\PYG{n}{nxx}\PYG{o}{:}\PYG{o}{:}\PYG{n}{roots}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Bisection}\PYG{p}{;}
\PYG{k}{using}\PYG{+w}{ }\PYG{n}{Outputter}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{decltype}\PYG{p}{(}\PYG{n}{outputter}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{fsolve}\PYG{o}{\PYGZlt{}}\PYG{n}{Bisection}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k}{return}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mf}{2.5}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{.}\PYG{n}{result}\PYG{o}{\PYGZlt{}}\PYG{n}{Outputter}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The outputter can be used to provide additional information about the result, such as the number of iterations that were performed, or the reason for stopping the iterations. This can be useful for logging or debugging purposes, or for providing more context about the result of the root\sphinxhyphen{}finding process.


\section{API Reference}
\label{\detokenize{docRoots:api-reference}}
\sphinxAtStartPar
This section provides a detailed reference for the root\sphinxhyphen{}finding functions. The reference includes the function signature, the template parameters, the function arguments, and the return type.


\subsection{fsolve}
\label{\detokenize{docRoots:fsolve}}
\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
doxygenfunction: Unable to find project ‘Numerixx’ in breathe\_projects dictionary
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
doxygenfunction: Unable to find project ‘Numerixx’ in breathe\_projects dictionary
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
doxygenfunction: Unable to find project ‘Numerixx’ in breathe\_projects dictionary
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
doxygenfunction: Unable to find project ‘Numerixx’ in breathe\_projects dictionary
\end{sphinxadmonition}


\subsection{fdfsolve}
\label{\detokenize{docRoots:fdfsolve}}
\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
doxygenfunction: Unable to find project ‘Numerixx’ in breathe\_projects dictionary
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
doxygenfunction: Unable to find project ‘Numerixx’ in breathe\_projects dictionary
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
doxygenfunction: Unable to find project ‘Numerixx’ in breathe\_projects dictionary
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
doxygenfunction: Unable to find project ‘Numerixx’ in breathe\_projects dictionary
\end{sphinxadmonition}


\subsection{search}
\label{\detokenize{docRoots:search}}
\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
doxygenfunction: Unable to find project ‘Numerixx’ in breathe\_projects dictionary
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
doxygenfunction: Unable to find project ‘Numerixx’ in breathe\_projects dictionary
\end{sphinxadmonition}


\subsection{Algorithms}
\label{\detokenize{docRoots:algorithms}}
\sphinxAtStartPar
The following algorithms are available for use with the root\sphinxhyphen{}finding functions:

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
doxygenclass: breathe\_default\_project value ‘Numerixx’ does not seem to be a valid key for the breathe\_projects dictionary
\end{sphinxadmonition}


\section{Design and Implementation Details}
\label{\detokenize{docRoots:design-and-implementation-details}}
\sphinxAtStartPar
The solver functions documented above should be sufficient for the vast majority of use cases. However, in some cases it may be necessary to use the solvers directly, or to create custom solvers. This section provides an overview of the design and implementation details of the solvers, and how they can be used and customized.


\subsection{Interface}
\label{\detokenize{docRoots:interface}}
\sphinxAtStartPar
Both the bracketing and polishing algorithms are implemented using the overall architecture: a base class is defined, for keeping track of internal state between iterations, and the individual algorithms inherits from the base class. However, in order to avoid virtual functions, the architecture is implemented using static polymorphism through the Curiously Recurring Template Pattern (CRTP) %
\begin{footnote}[1]\sphinxAtStartFootnote
Vandevoorde, D., Josuttis, N., Gregor, D. (2018). C++ Templates \sphinxhyphen{} The Complete Guide
%
\end{footnote}.

\sphinxAtStartPar
The purpose of this design is that it avoids dynamic polymorphim and virtual functions, while ensuring that the solvers share a common interface. The downside of this approach is that all dependencies has to be resolved during compile\sphinxhyphen{}time, and it is not possible to dynamically plug in a different solver.

\sphinxAtStartPar
While the base classes (BracketingBase and PolishingBase, respectively) will not be called directly in client code, it is useful to know what the classes look like, as the individual solvers will inherit the interface of the base classes.


\subsubsection{BracketingBase}
\label{\detokenize{docRoots:bracketingbase}}
\sphinxAtStartPar
The BracketingBase class (located in the \sphinxcode{\sphinxupquote{root::detail}} namespace) look as follows:

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
doxygenclass: breathe\_default\_project value ‘Numerixx’ does not seem to be a valid key for the breathe\_projects dictionary
\end{sphinxadmonition}


\subsubsection{PolishingBase}
\label{\detokenize{docRoots:polishingbase}}
\sphinxAtStartPar
Similarly, the PolishingBase class (located in the \sphinxcode{\sphinxupquote{root::detail}} namespace) look as follows:

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
doxygenclass: breathe\_default\_project value ‘Numerixx’ does not seem to be a valid key for the breathe\_projects dictionary
\end{sphinxadmonition}


\subsection{Implementation}
\label{\detokenize{docRoots:implementation}}
\sphinxAtStartPar
The implementation of the solvers is based on the algorithms described in the previous sections. The solvers are implemented as classes, with the individual algorithms being implemented through the function call operator (\sphinxcode{\sphinxupquote{operator()}}). This makes the implementation reasonably straightforward and easy to understand.

\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}



\renewcommand{\indexname}{Index}
\printindex
\end{document}