<!doctype html>
<html class="no-js" lang="en" data-content_root="./">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="genindex.html" /><link rel="search" title="Search" href="search.html" /><link rel="prev" title="Numerical Derivatives" href="docDerivative.html" />

    <!-- Generated with Sphinx 7.2.6 and Furo 2023.09.10 -->
        <title>One-Dimensional Root-Finding - Numerixx 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo.css?v=135e06be" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo-extensions.css?v=36a5483c" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="index.html"><div class="brand">Numerixx 0.0.1 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="index.html">
  
  
  <span class="sidebar-brand-text">Numerixx 0.0.1 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="docIntro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="docError.html">A Word About Error Handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="docPolynomial.html">Polynomials</a></li>
<li class="toctree-l1"><a class="reference internal" href="docDerivative.html">Numerical Derivatives</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">One-Dimensional Root-Finding</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="one-dimensional-root-finding">
<h1>One-Dimensional Root-Finding<a class="headerlink" href="#one-dimensional-root-finding" title="Link to this heading">#</a></h1>
<p>This section delves into a range of classes and functions dedicated to the finding roots in one-dimensional functions. The featured algorithms are divided into two main types: bracketing algorithms, which operate without the need for function derivatives, and polishing algorithms, which require the computation of the function’s derivative. In addition, the library offers search algorithms that can be used to find a bracket where a root exists when the initial guess is not near the actual root.</p>
<p>All functions are available through the <code class="file docutils literal notranslate"><span class="pre">Roots.hpp</span></code> header file.</p>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Link to this heading">#</a></h2>
<p>Popular one-dimensional root-finding methods encompass the bisection method, Newton’s method, Ridder’s method, and the secant method. Each of these methods brings its unique advantages and potential drawbacks, and their applicability hinges on the nature of the problem at hand.</p>
<p>Bracketing methods such as the bisection method and Ridder’s method are designed to locate a root within a specified interval. These methods are particularly useful when the function’s derivative is unavailable or when the function is not differentiable. The bisection method, in particular, is known for its simplicity and reliability, as it guarantees convergence to a root as long as the function is continuous and changes sign within the interval. Ridder’s method, on the other hand, can converge with fewer iterations, but each iteration is more computationally expensive.</p>
<p>The following bracketing methods are available in the library:</p>
<ul class="simple">
<li><p><strong>Bisection Method</strong>: Known for its reliability and surefire convergence, the bisection method is a good choice when you need a method that is guaranteed to find a root. However, it can sometimes converge at a slower pace compared to other methods. (Wikipedia: <a class="reference external" href="https://en.wikipedia.org/wiki/Bisection_method">Bisection Method</a>)</p></li>
<li><p><strong>Ridder’s Method</strong>: Outpacing the bisection method, Ridder’s method can converge more rapidly. However, each iteration is more computationally expensive, and the function must have a continuous second derivative. (Wikipedia: <a class="reference external" href="https://en.wikipedia.org/wiki/Ridder%27s_method">Ridder’s Method</a>)</p></li>
<li><p><strong>Regula Falsi Method</strong>: Also known as the false position method, the regula falsi method is a bracketing algorithm that uses linear interpolation to find the root of a function. It is similar to the bisection method, but it can converge faster in some cases. (Wikipedia: <a class="reference external" href="https://en.wikipedia.org/wiki/Regula_falsi">Regula Falsi Method</a>)</p></li>
</ul>
<p>Polishing methods, such as Newton’s method and Steffensen’s method, are designed to refine an initial guess to find a root. These methods are generally faster than bracketing methods, but they require the first derivative of the function to be available. Newton’s method, in particular, is known for its speed and efficiency, but it may fail to converge or converge to a local minimum instead of a root.</p>
<p>The following polishing methods are available in the library:</p>
<ul class="simple">
<li><p><strong>Newton’s Method</strong>: A popular root-finding algorithm, Newton’s method is known for its speed and efficiency. However, it requires the function to be differentiable and the derivative to be non-zero at the estimate. (Wikipedia: <a class="reference external" href="https://en.wikipedia.org/wiki/Newton%27s_method">Newton’s Method</a>)</p></li>
<li><p><strong>Secant Method</strong>: The secant method is a root-finding algorithm that does not require the derivative of the function. It is similar to the Newton-Raphson method, but it uses a finite difference approximation to the derivative. (Wikipedia: <a class="reference external" href="https://en.wikipedia.org/wiki/Secant_method">Secant Method</a>)</p></li>
<li><p><strong>Steffensen’s Method</strong>: Steffensen’s method is an iterative root-finding algorithm that improves upon the simple fixed-point iteration by incorporating a form of Aitken’s Δ² process. This method is particularly effective for functions where the derivative is difficult to compute or is not readily available. (Wikipedia: <a class="reference external" href="https://en.wikipedia.org/wiki/Steffensen%27s_method">Steffensen’s Method</a>)</p></li>
</ul>
<p>Search methods, such as BracketSearchUp and BracketSearchDown, are designed to incrementally expand or subdivide the search bounds to find a bracket where a root exists. These methods are useful when the initial guess is not near the actual root.</p>
<p>The following search methods are available in the library:</p>
<ul class="simple">
<li><p><strong>BracketSearchUp</strong>: A specialized search algorithm designed to incrementally expand the search bounds upwards (increasing values) to find a bracket where a root exists.</p></li>
<li><p><strong>BracketSearchDown</strong>: A specialized search algorithm designed to incrementally expand the search bounds downwards (decreasing values) to find a bracket where a root exists.</p></li>
<li><p><strong>BracketExpandUp</strong>: A specialized search algorithm designed to incrementally expand the upper bound upwards (increasing values) while keeping the lower bound fixed. This is useful for finding a bracket where a root exists when the initial guess is lower than the actual root.</p></li>
<li><p><strong>BracketExpandDown</strong>: A specialized search algorithm designed to incrementally expand the lower bound downwards (decreasing values) while keeping the upper bound fixed. This is useful for finding a bracket where a root exists when the initial guess is higher than the actual root.</p></li>
<li><p><strong>BracketExpandOut</strong>: A specialized search algorithm designed to incrementally expand both the lower and upper bounds symmetrically outwards. This is useful for finding a bracket where a root exists when the initial guess is not near the actual root.</p></li>
<li><p><strong>BracketSubdivide</strong>: A specialized search algorithm designed to subdivide the current search bounds into smaller segments in an attempt to find a bracket where a root exists.</p></li>
</ul>
<p>Using these methods should be done through the <code class="code docutils literal notranslate"><span class="pre">fsolve</span></code>, <code class="code docutils literal notranslate"><span class="pre">fdfsolve</span></code>, and <code class="code docutils literal notranslate"><span class="pre">search</span></code> functions, which are designed to be easy to use and provide a consistent interface for all the solvers.</p>
</section>
<section id="important-considerations">
<h2>Important Considerations<a class="headerlink" href="#important-considerations" title="Link to this heading">#</a></h2>
<p>It’s imperative to recognize that root-finding functions are designed to locate a single root at any given instance. In cases where multiple roots are present within the search range, the function will identify and return the initial root it encounters. Pinpointing which root will be found in a region with several roots is generally unpredictable. Notably, attempting to find a root in such areas usually doesn’t trigger any error messages, despite the inherent challenges.</p>
</section>
<section id="quick-start">
<h2>Quick Start<a class="headerlink" href="#quick-start" title="Link to this heading">#</a></h2>
<p>The library provides the following functions for finding roots in one-dimensional functions:</p>
<ul class="simple">
<li><p><strong>fsolve</strong>: A function for finding a root of a one-dimensional function using a bracketing method. It takes a bracketing method object and an initial bracket around the root to be found.</p></li>
<li><p><strong>fdfsolve</strong>: A function for finding a root of a one-dimensional function using a polishing method. It takes a polishing method object and an initial guess for the root.</p></li>
<li><p><strong>search</strong>: A function for finding a bracket where a root exists when the initial guess is not near the actual root. It takes a search method object and an initial guess for the root.</p></li>
</ul>
<p>These functions return a proxy object that contains the result of the root-finding process. The result can be accessed using the <code class="code docutils literal notranslate"><span class="pre">result</span></code> member function, which returns the estimated root.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The proxy objects returned by the root-finding functions are not intended to be stored or passed around. They are designed to be used immediately to access the result of the root-finding process. Consequently, they cannot be copied or moved, and the member functions are only available for r-value references.</p>
</div>
<p>The following example shows how to find the root of the function <span class="math notranslate nohighlight">\(f(x) = x^2 - 5\)</span> (defined as a lambda) using a bracketing method:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">nxx</span><span class="o">::</span><span class="n">roots</span><span class="o">::</span><span class="n">fsolve</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">nxx</span><span class="o">::</span><span class="n">roots</span><span class="o">::</span><span class="n">Bisection</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fsolve</span><span class="o">&lt;</span><span class="n">Bisection</span><span class="o">&gt;</span><span class="p">([](</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">){</span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">5</span><span class="p">;}),</span><span class="w"> </span><span class="p">{</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.5</span><span class="p">}).</span><span class="n">result</span><span class="p">();</span>
</pre></div>
</div>
<p>Similarly, the same function can be solved using Newton’s method (with the derivative being <span class="math notranslate nohighlight">\(f'(x) = 2x\)</span>)</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">nxx</span><span class="o">::</span><span class="n">roots</span><span class="o">::</span><span class="n">fdfsolve</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">nxx</span><span class="o">::</span><span class="n">roots</span><span class="o">::</span><span class="n">Newton</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fdfsolve</span><span class="o">&lt;</span><span class="n">Newton</span><span class="o">&gt;</span><span class="p">([](</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">){</span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">5</span><span class="p">;},</span>
<span class="w">                               </span><span class="p">[](</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">){</span><span class="k">return</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">;}),</span><span class="w"> </span><span class="mf">1.25</span><span class="p">).</span><span class="n">result</span><span class="p">();</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The derivative is not required to be provided, as it will be computed numerically using a finite difference approximation. However, this can be less accurate and less efficient than providing the derivative directly.</p>
</div>
<p>Finally, the following example shows how to find a bracket where a root exists when the initial guess is not near the actual root:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">nxx</span><span class="o">::</span><span class="n">roots</span><span class="o">::</span><span class="n">search</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">nxx</span><span class="o">::</span><span class="n">roots</span><span class="o">::</span><span class="n">BracketSearchUp</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">search</span><span class="o">&lt;</span><span class="n">BracketSearchUp</span><span class="o">&gt;</span><span class="p">([](</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">){</span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">5</span><span class="p">;},</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">}).</span><span class="n">result</span><span class="p">();</span>
</pre></div>
</div>
<p>In addition to the arguments provided in the examples above, the root-finding functions also take two optional arguments for terminating the iterations, namely the relative error (epsilon) and the maximum number of iterations. Those arguments can be provided in any order; the only requirement is that epsilon must be a floating-point number and the maximum number of iterations must be an integer.</p>
<p>As can be seen from the previous examples, the root-finding solvers can be invoked in a single line of code, which makes them very easy to use.</p>
</section>
<section id="advanced-usage">
<h2>Advanced Usage<a class="headerlink" href="#advanced-usage" title="Link to this heading">#</a></h2>
<p>Although using the root-finding functions and algorithms can be as simple as shown in the previous examples, there are a number of advanced features and considerations that can be useful in more complex scenarios.</p>
<section id="customizing-the-solvers">
<h3>Customizing the Solvers<a class="headerlink" href="#customizing-the-solvers" title="Link to this heading">#</a></h3>
<p>In many cases, the default settings of the solvers will be sufficient. However, in some cases it may be required to provide more fine-grained control over the solvers and the criteria for terminating the iterations. This can be done by creating a “stop token” object and passing it to the solver.</p>
<p>A stop token is an object that provides a way to stop the iterations of the solver based on a set of criteria. It can be any callable object, such as a lambda, that takes the solver’s state as an argument and returns a boolean value indicating whether the iterations should continue or stop. The stop token can be used to check for convergence, reach a maximum number of iterations, or any other condition that should stop the iterations.</p>
<p>The following example shows how to create a custom stop token and use it with the <code class="code docutils literal notranslate"><span class="pre">fsolve</span></code> function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">nxx</span><span class="o">::</span><span class="n">roots</span><span class="o">::</span><span class="n">fsolve</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">nxx</span><span class="o">::</span><span class="n">roots</span><span class="o">::</span><span class="n">Bisection</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">stop_token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">solver</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">solver</span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
<span class="k">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fsolve</span><span class="o">&lt;</span><span class="n">Bisection</span><span class="o">&gt;</span><span class="p">([](</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">){</span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">5</span><span class="p">;}),</span><span class="w"> </span><span class="p">{</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.5</span><span class="p">},</span><span class="w"> </span><span class="n">stop_token</span><span class="p">).</span><span class="n">result</span><span class="p">();</span>
</pre></div>
</div>
<p>In this example, the stop token is a lambda that checks whether the number of iterations has reached 100. If the condition is met, the iterations will stop and the result will be returned.</p>
<p>As an alternative to providing the stop token as a function argument, it can also be provided as a second template argument, after the solver algorithm. This can be useful when the stop token is a complex type or when it needs to be reused with multiple solvers:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">nxx</span><span class="o">::</span><span class="n">roots</span><span class="o">::</span><span class="n">fsolve</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">nxx</span><span class="o">::</span><span class="n">roots</span><span class="o">::</span><span class="n">Bisection</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">stop_token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">solver</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">solver</span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
<span class="k">using</span><span class="w"> </span><span class="n">StopToken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="n">stop_token</span><span class="p">);</span>
<span class="k">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fsolve</span><span class="o">&lt;</span><span class="n">Bisection</span><span class="p">,</span><span class="w"> </span><span class="n">StopToken</span><span class="o">&gt;</span><span class="p">([](</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">){</span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">5</span><span class="p">;}),</span><span class="w"> </span><span class="p">{</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.5</span><span class="p">}).</span><span class="n">result</span><span class="p">();</span>
</pre></div>
</div>
<p>Both syntaxes are equivalent, so which one to use is a matter of taste.</p>
<p>However, determining when to terminate the iterations is not the only use of the stop token object; it can also be used to provide additional information about the iterations, such as the number of iterations that have been performed. This can be useful for logging or debugging purposes:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">nxx</span><span class="o">::</span><span class="n">roots</span><span class="o">::</span><span class="n">fsolve</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">nxx</span><span class="o">::</span><span class="n">roots</span><span class="o">::</span><span class="n">Bisection</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">stop_token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">solver</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Iteration: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">solver</span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; | &quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Guess:     &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">solver</span><span class="p">.</span><span class="n">guess</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">solver</span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
<span class="k">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fsolve</span><span class="o">&lt;</span><span class="n">Bisection</span><span class="o">&gt;</span><span class="p">([](</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">){</span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">5</span><span class="p">;}),</span><span class="w"> </span><span class="p">{</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.5</span><span class="p">},</span><span class="w"> </span><span class="n">stop_token</span><span class="p">).</span><span class="n">result</span><span class="p">();</span>
</pre></div>
</div>
<p>This example shows how the stop token can be used to print the iteration number and the current guess at each iteration. This can be useful for understanding how the solver is converging and for diagnosing any issues that may arise. The output can be redirected to a file or a log for further analysis.</p>
<p>Finally, a stop token can also be used to deal with errors. For example, if reaching the maximum number of iterations is considered an error, the stop token can be used to throw an exception when the condition is met. Or if the current guess of the root is NaN or infinite, the stop token can be used to throw an exception as well:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">nxx</span><span class="o">::</span><span class="n">roots</span><span class="o">::</span><span class="n">fsolve</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">nxx</span><span class="o">::</span><span class="n">roots</span><span class="o">::</span><span class="n">Bisection</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">stop_token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">solver</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">solver</span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Maximum number of iterations reached&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">isnan</span><span class="p">(</span><span class="n">solver</span><span class="p">.</span><span class="n">guess</span><span class="p">())</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">isinf</span><span class="p">(</span><span class="n">solver</span><span class="p">.</span><span class="n">guess</span><span class="p">()))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Invalid root&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
<span class="k">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fsolve</span><span class="o">&lt;</span><span class="n">Bisection</span><span class="o">&gt;</span><span class="p">([](</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">){</span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">5</span><span class="p">;}),</span><span class="w"> </span><span class="p">{</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.5</span><span class="p">},</span><span class="w"> </span><span class="n">stop_token</span><span class="p">).</span><span class="n">result</span><span class="p">();</span>
</pre></div>
</div>
<p>As the previous examples show, the stop token can be used to provide fine-grained control over the solvers and the criteria for terminating the iterations. This can be useful in a wide range of scenarios, from simple cases where the default settings are sufficient to complex cases where more control is needed.</p>
</section>
<section id="customizing-the-output">
<h3>Customizing the Output<a class="headerlink" href="#customizing-the-output" title="Link to this heading">#</a></h3>
<p>In addition to customizing the solvers, it is also possible to customize the output of the root-finding functions. As mentioned earlier, the solver functions return a proxy object that contains the result of the root-finding process. This proxy object can be used to access the final result of the root-finding, using the <code class="code docutils literal notranslate"><span class="pre">result</span></code> member function.</p>
<p>In some cases, however, it may be useful to access additional information about the result, or to get the result in a different format. In the simplest form, a type that can be constructed from a floating point number, can be passed as a template argument to the <code class="code docutils literal notranslate"><span class="pre">result</span></code> function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">nxx</span><span class="o">::</span><span class="n">roots</span><span class="o">::</span><span class="n">fsolve</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">nxx</span><span class="o">::</span><span class="n">roots</span><span class="o">::</span><span class="n">Bisection</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fsolve</span><span class="o">&lt;</span><span class="n">Bisection</span><span class="o">&gt;</span><span class="p">([](</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">){</span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">5</span><span class="p">;}),</span><span class="w"> </span><span class="p">{</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.5</span><span class="p">}).</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<p>In more complex scenarios, a callable object, such as a lambda, can be passed as an argument. This can be usefule in situations where some error condition need to be reported, but where throwing an exception is not appropriate. This could be the C++23 std::expected type, or one of the alternatives such as tl::expected from TartanLlama:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">nxx</span><span class="o">::</span><span class="n">roots</span><span class="o">::</span><span class="n">fsolve</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">nxx</span><span class="o">::</span><span class="n">roots</span><span class="o">::</span><span class="n">Bisection</span><span class="p">;</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">outputter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">tl</span><span class="o">::</span><span class="n">expected</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">guess</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">iter</span><span class="p">,</span><span class="w"> </span><span class="n">guess</span><span class="p">,</span><span class="w"> </span><span class="n">previous</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">expected</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tl</span><span class="o">::</span><span class="n">expected</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">guess</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iter</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">tl</span><span class="o">::</span><span class="n">make_unexpected</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;Too many iterations&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">expected</span><span class="p">(</span><span class="n">guess</span><span class="p">);</span>
<span class="p">};</span>
<span class="k">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fsolve</span><span class="o">&lt;</span><span class="n">Bisection</span><span class="o">&gt;</span><span class="p">([](</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">){</span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">5</span><span class="p">;}),</span><span class="w"> </span><span class="p">{</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.5</span><span class="p">}).</span><span class="n">result</span><span class="p">(</span><span class="n">outputter</span><span class="p">);</span>
</pre></div>
</div>
<p>The outputter can also be provided as a template argument. The functioanlity is the same,  so which one to use is a matter of taste:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">nxx</span><span class="o">::</span><span class="n">roots</span><span class="o">::</span><span class="n">fsolve</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">nxx</span><span class="o">::</span><span class="n">roots</span><span class="o">::</span><span class="n">Bisection</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">Outputter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="n">outputter</span><span class="p">);</span>
<span class="k">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fsolve</span><span class="o">&lt;</span><span class="n">Bisection</span><span class="o">&gt;</span><span class="p">([](</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">){</span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">5</span><span class="p">;}),</span><span class="w"> </span><span class="p">{</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.5</span><span class="p">}).</span><span class="n">result</span><span class="o">&lt;</span><span class="n">Outputter</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<p>The outputter can be used to provide additional information about the result, such as the number of iterations that were performed, or the reason for stopping the iterations. This can be useful for logging or debugging purposes, or for providing more context about the result of the root-finding process.</p>
</section>
</section>
<section id="api-reference">
<h2>API Reference<a class="headerlink" href="#api-reference" title="Link to this heading">#</a></h2>
<p>This section provides a detailed reference for the root-finding functions. The reference includes the function signature, the template parameters, the function arguments, and the return type.</p>
<section id="fsolve">
<h3>fsolve<a class="headerlink" href="#fsolve" title="Link to this heading">#</a></h3>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4II00E0_25IsFloatOrComplexInvocable_13IsFloatStructDpEN3nxx5roots6fsolveEDa4FN_T8STRUCT_TDp4ARGS">
<span id="_CPPv3II00E0_25IsFloatOrComplexInvocable_13IsFloatStructDpEN3nxx5roots6fsolveE4FN_T8STRUCT_TDp4ARGS"></span><span id="_CPPv2II00E0_25IsFloatOrComplexInvocable_13IsFloatStructDpEN3nxx5roots6fsolveE4FN_T8STRUCT_TDp4ARGS"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SOLVER_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">IsFloatOrComplexInvocable</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FN_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">IsFloatStruct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">STRUCT_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="sig-name descname"><span class="n"><span class="pre">ARGS</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="_root_bracketing_8hpp_1adaa4de11835bce8817fcac946f30a492"></span><span class="kt"><span class="pre">auto</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">nxx</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">roots</span></span><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">fsolve</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4II00E0_25IsFloatOrComplexInvocable_13IsFloatStructDpEN3nxx5roots6fsolveEDa4FN_T8STRUCT_TDp4ARGS" title="nxx::roots::fsolve::FN_T"><span class="n"><span class="pre">FN_T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">func</span></span>, <a class="reference internal" href="#_CPPv4II00E0_25IsFloatOrComplexInvocable_13IsFloatStructDpEN3nxx5roots6fsolveEDa4FN_T8STRUCT_TDp4ARGS" title="nxx::roots::fsolve::STRUCT_T"><span class="n"><span class="pre">STRUCT_T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">bounds</span></span>, <a class="reference internal" href="#_CPPv4II00E0_25IsFloatOrComplexInvocable_13IsFloatStructDpEN3nxx5roots6fsolveEDa4FN_T8STRUCT_TDp4ARGS" title="nxx::roots::fsolve::ARGS"><span class="n"><span class="pre">ARGS</span></span></a><span class="p"><span class="pre">...</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">args</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4II00E0_25IsFloatOrComplexInvocable_13IsFloatStructDpEN3nxx5roots6fsolveEDa4FN_T8STRUCT_TDp4ARGS" title="Link to this definition">#</a><br /></dt>
<dd><p>A function template that solves a root-finding problem using a specified solver and termination condition. </p>
<p>This function template is an overload of the fsolve function that accepts a structure for the bounds. It uses a specified solver to find the root of a given function within the provided bounds. The termination condition for the solver is specified by a callable object.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function requires that the termination condition callable is invocable with an IterData object. </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>SOLVER_T</strong> – The type of the solver to use for the root-finding problem. Must be a template class that accepts two type parameters. </p></li>
<li><p><strong>FN_T</strong> – The type of the function for which the root is being found. Must be invocable with a floating point or complex number. </p></li>
<li><p><strong>STRUCT_T</strong> – The type of the structure for the bounds. </p></li>
<li><p><strong>ARGS</strong> – The type of the additional arguments. These arguments are passed to the fsolve_common function. </p></li>
</ul>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>func</strong> – The function for which the root is being found. </p></li>
<li><p><strong>bounds</strong> – The bounds within which the root is being found. Must be a structure. </p></li>
<li><p><strong>args</strong> – The additional arguments passed to the fsolve_common function. </p></li>
</ul>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The result of the root-finding problem. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4II00E00_25IsFloatOrComplexInvocable_13IsFloatStructEN3nxx5roots6fsolveEDa4FN_T8STRUCT_T">
<span id="_CPPv3II00E00_25IsFloatOrComplexInvocable_13IsFloatStructEN3nxx5roots6fsolveE4FN_T8STRUCT_T"></span><span id="_CPPv2II00E00_25IsFloatOrComplexInvocable_13IsFloatStructEN3nxx5roots6fsolveE4FN_T8STRUCT_T"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SOLVER_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">TOKEN_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">IsFloatOrComplexInvocable</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FN_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">IsFloatStruct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">STRUCT_T</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="_root_bracketing_8hpp_1a3f9c4b98a46947daa7cb1a2cfddd7a8c"></span><span class="kt"><span class="pre">auto</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">nxx</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">roots</span></span><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">fsolve</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4II00E00_25IsFloatOrComplexInvocable_13IsFloatStructEN3nxx5roots6fsolveEDa4FN_T8STRUCT_T" title="nxx::roots::fsolve::FN_T"><span class="n"><span class="pre">FN_T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">func</span></span>, <a class="reference internal" href="#_CPPv4II00E00_25IsFloatOrComplexInvocable_13IsFloatStructEN3nxx5roots6fsolveEDa4FN_T8STRUCT_T" title="nxx::roots::fsolve::STRUCT_T"><span class="n"><span class="pre">STRUCT_T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">bounds</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4II00E00_25IsFloatOrComplexInvocable_13IsFloatStructEN3nxx5roots6fsolveEDa4FN_T8STRUCT_T" title="Link to this definition">#</a><br /></dt>
<dd><p>A function template that solves a root-finding problem using a specified solver and termination condition. </p>
<p>This function template is an overload of the fsolve function that accepts a structure for the bounds. It uses a specified solver to find the root of a given function within the provided bounds. The termination condition for the solver is specified by a callable object.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function requires that the termination condition callable is invocable with an IterData object. </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>SOLVER_T</strong> – The type of the solver to use for the root-finding problem. Must be a template class that accepts two type parameters. </p></li>
<li><p><strong>TOKEN_T</strong> – The type of the callable object that specifies the termination condition for the solver. </p></li>
<li><p><strong>FN_T</strong> – The type of the function for which the root is being found. Must be invocable with a floating point or complex number. </p></li>
<li><p><strong>STRUCT_T</strong> – The type of the structure for the bounds. </p></li>
</ul>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>func</strong> – The function for which the root is being found. </p></li>
<li><p><strong>bounds</strong> – The bounds within which the root is being found. Must be a structure. </p></li>
</ul>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The result of the root-finding problem. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4II00E0_25IsFloatOrComplexInvocable_7IsFloat_6size_tDpEN3nxx5roots6fsolveEDa4FN_TRA1N_K5ARG_TDp4ARGS">
<span id="_CPPv3II00E0_25IsFloatOrComplexInvocable_7IsFloat_6size_tDpEN3nxx5roots6fsolveE4FN_TRA1N_K5ARG_TDp4ARGS"></span><span id="_CPPv2II00E0_25IsFloatOrComplexInvocable_7IsFloat_6size_tDpEN3nxx5roots6fsolveE4FN_TRAN_K5ARG_TDp4ARGS"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SOLVER_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">IsFloatOrComplexInvocable</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FN_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">IsFloat</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ARG_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">N</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="sig-name descname"><span class="n"><span class="pre">ARGS</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="_root_bracketing_8hpp_1a8e4bca52e9f922935729deca2cfb1766"></span><span class="kt"><span class="pre">auto</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">nxx</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">roots</span></span><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">fsolve</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4II00E0_25IsFloatOrComplexInvocable_7IsFloat_6size_tDpEN3nxx5roots6fsolveEDa4FN_TRA1N_K5ARG_TDp4ARGS" title="nxx::roots::fsolve::FN_T"><span class="n"><span class="pre">FN_T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">func</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4II00E0_25IsFloatOrComplexInvocable_7IsFloat_6size_tDpEN3nxx5roots6fsolveEDa4FN_TRA1N_K5ARG_TDp4ARGS" title="nxx::roots::fsolve::ARG_T"><span class="n"><span class="pre">ARG_T</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">bounds</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#_CPPv4II00E0_25IsFloatOrComplexInvocable_7IsFloat_6size_tDpEN3nxx5roots6fsolveEDa4FN_TRA1N_K5ARG_TDp4ARGS" title="nxx::roots::fsolve::N"><span class="n"><span class="pre">N</span></span></a><span class="p"><span class="pre">]</span></span>, <a class="reference internal" href="#_CPPv4II00E0_25IsFloatOrComplexInvocable_7IsFloat_6size_tDpEN3nxx5roots6fsolveEDa4FN_TRA1N_K5ARG_TDp4ARGS" title="nxx::roots::fsolve::ARGS"><span class="n"><span class="pre">ARGS</span></span></a><span class="p"><span class="pre">...</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">args</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4II00E0_25IsFloatOrComplexInvocable_7IsFloat_6size_tDpEN3nxx5roots6fsolveEDa4FN_TRA1N_K5ARG_TDp4ARGS" title="Link to this definition">#</a><br /></dt>
<dd><p>A function template that solves a root-finding problem using a specified solver and termination condition. </p>
<p>This function template is an overload of the fsolve function that accepts a fixed-size array for the bounds. It uses a specified solver to find the root of a given function within the provided bounds. The termination condition for the solver is specified by a callable object.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function requires that the termination condition callable is invocable with an IterData object. </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>SOLVER_T</strong> – The type of the solver to use for the root-finding problem. Must be a template class that accepts two type parameters. </p></li>
<li><p><strong>FN_T</strong> – The type of the function for which the root is being found. Must be invocable with a floating point or complex number. </p></li>
<li><p><strong>ARG_T</strong> – The type of the argument to the function. Must be a floating point number. </p></li>
<li><p><strong>N</strong> – The size of the array for the bounds. Must be 2. </p></li>
<li><p><strong>ARGS...</strong> – The type of the additional arguments. These arguments are passed to the fsolve_common function. </p></li>
</ul>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>func</strong> – The function for which the root is being found. </p></li>
<li><p><strong>bounds</strong> – The bounds within which the root is being found. Must be a fixed-size array of 2 elements. </p></li>
<li><p><strong>args</strong> – The additional arguments passed to the fsolve_common function. </p></li>
</ul>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The result of the root-finding problem. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4II00E00_25IsFloatOrComplexInvocable_7IsFloat_6size_tEN3nxx5roots6fsolveEDa4FN_TRA1N_K5ARG_T">
<span id="_CPPv3II00E00_25IsFloatOrComplexInvocable_7IsFloat_6size_tEN3nxx5roots6fsolveE4FN_TRA1N_K5ARG_T"></span><span id="_CPPv2II00E00_25IsFloatOrComplexInvocable_7IsFloat_6size_tEN3nxx5roots6fsolveE4FN_TRAN_K5ARG_T"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SOLVER_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">TOKEN_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">IsFloatOrComplexInvocable</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FN_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">IsFloat</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ARG_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">N</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="_root_bracketing_8hpp_1a0960c06991425445e8f21af9282211d8"></span><span class="kt"><span class="pre">auto</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">nxx</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">roots</span></span><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">fsolve</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4II00E00_25IsFloatOrComplexInvocable_7IsFloat_6size_tEN3nxx5roots6fsolveEDa4FN_TRA1N_K5ARG_T" title="nxx::roots::fsolve::FN_T"><span class="n"><span class="pre">FN_T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">func</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4II00E00_25IsFloatOrComplexInvocable_7IsFloat_6size_tEN3nxx5roots6fsolveEDa4FN_TRA1N_K5ARG_T" title="nxx::roots::fsolve::ARG_T"><span class="n"><span class="pre">ARG_T</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">bounds</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#_CPPv4II00E00_25IsFloatOrComplexInvocable_7IsFloat_6size_tEN3nxx5roots6fsolveEDa4FN_TRA1N_K5ARG_T" title="nxx::roots::fsolve::N"><span class="n"><span class="pre">N</span></span></a><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4II00E00_25IsFloatOrComplexInvocable_7IsFloat_6size_tEN3nxx5roots6fsolveEDa4FN_TRA1N_K5ARG_T" title="Link to this definition">#</a><br /></dt>
<dd><p>A function template that solves a root-finding problem using a specified solver and termination condition. </p>
<p>This function template is an overload of the fsolve function that accepts a fixed-size array for the bounds. It uses a specified solver to find the root of a given function within the provided bounds. The termination condition for the solver is specified by a callable object.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function requires that the termination condition callable is invocable with an IterData object. </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>SOLVER_T</strong> – The type of the solver to use for the root-finding problem. Must be a template class that accepts two type parameters. </p></li>
<li><p><strong>TOKEN_T</strong> – The type of the callable object that specifies the termination condition for the solver. </p></li>
<li><p><strong>FN_T</strong> – The type of the function for which the root is being found. Must be invocable with a floating point or complex number. </p></li>
<li><p><strong>ARG_T</strong> – The type of the argument to the function. Must be a floating point number. </p></li>
<li><p><strong>N</strong> – The size of the array for the bounds. Must be 2. </p></li>
</ul>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>func</strong> – The function for which the root is being found. </p></li>
<li><p><strong>bounds</strong> – The bounds within which the root is being found. Must be a fixed-size array of 2 elements. </p></li>
</ul>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The result of the root-finding problem. </p>
</dd>
</dl>
</dd></dl>

</section>
<section id="fdfsolve">
<h3>fdfsolve<a class="headerlink" href="#fdfsolve" title="Link to this heading">#</a></h3>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4II000E0_25IsFloatOrComplexInvocable_25IsFloatOrComplexInvocable_16IsFloatOrComplexDpEN3nxx5roots8fdfsolveEDa4FN_T7DERIV_T7GUESS_TDp4ARGS">
<span id="_CPPv3II000E0_25IsFloatOrComplexInvocable_25IsFloatOrComplexInvocable_16IsFloatOrComplexDpEN3nxx5roots8fdfsolveE4FN_T7DERIV_T7GUESS_TDp4ARGS"></span><span id="_CPPv2II000E0_25IsFloatOrComplexInvocable_25IsFloatOrComplexInvocable_16IsFloatOrComplexDpEN3nxx5roots8fdfsolveE4FN_T7DERIV_T7GUESS_TDp4ARGS"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SOLVER_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">IsFloatOrComplexInvocable</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FN_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">IsFloatOrComplexInvocable</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">DERIV_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">IsFloatOrComplex</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GUESS_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="sig-name descname"><span class="n"><span class="pre">ARGS</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="_root_polishing_8hpp_1a89a37d49cdad52f50d6a2f47404cd657"></span><span class="kt"><span class="pre">auto</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">nxx</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">roots</span></span><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">fdfsolve</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4II000E0_25IsFloatOrComplexInvocable_25IsFloatOrComplexInvocable_16IsFloatOrComplexDpEN3nxx5roots8fdfsolveEDa4FN_T7DERIV_T7GUESS_TDp4ARGS" title="nxx::roots::fdfsolve::FN_T"><span class="n"><span class="pre">FN_T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">func</span></span>, <a class="reference internal" href="#_CPPv4II000E0_25IsFloatOrComplexInvocable_25IsFloatOrComplexInvocable_16IsFloatOrComplexDpEN3nxx5roots8fdfsolveEDa4FN_T7DERIV_T7GUESS_TDp4ARGS" title="nxx::roots::fdfsolve::DERIV_T"><span class="n"><span class="pre">DERIV_T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">derivative</span></span>, <a class="reference internal" href="#_CPPv4II000E0_25IsFloatOrComplexInvocable_25IsFloatOrComplexInvocable_16IsFloatOrComplexDpEN3nxx5roots8fdfsolveEDa4FN_T7DERIV_T7GUESS_TDp4ARGS" title="nxx::roots::fdfsolve::GUESS_T"><span class="n"><span class="pre">GUESS_T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">guess</span></span>, <a class="reference internal" href="#_CPPv4II000E0_25IsFloatOrComplexInvocable_25IsFloatOrComplexInvocable_16IsFloatOrComplexDpEN3nxx5roots8fdfsolveEDa4FN_T7DERIV_T7GUESS_TDp4ARGS" title="nxx::roots::fdfsolve::ARGS"><span class="n"><span class="pre">ARGS</span></span></a><span class="p"><span class="pre">...</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">args</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4II000E0_25IsFloatOrComplexInvocable_25IsFloatOrComplexInvocable_16IsFloatOrComplexDpEN3nxx5roots8fdfsolveEDa4FN_T7DERIV_T7GUESS_TDp4ARGS" title="Link to this definition">#</a><br /></dt>
<dd><p>A function template that solves a root finding problem using a specified solver. </p>
<p>This function template, <code class="docutils literal notranslate"><span class="pre">fdfsolve</span></code>, provides a generic implementation for root finding algorithms that utilize polishing solvers. It is designed to work with solvers that conform to the requirements of polishing solvers, such as having a defined <code class="docutils literal notranslate"><span class="pre">IsPolishingSolver</span></code> static member, initialization, and iteration methods. The function handles initialization, iteration, and convergence checking, returning the result along with any potential errors encountered during the solving process.</p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>SOLVER_T</strong> – The template class of the solver to be used. Must be a valid polishing solver type. </p></li>
<li><p><strong>FN_T</strong> – The type of the function for which the root is being refined. </p></li>
<li><p><strong>DERIV_T</strong> – The type of the derivative function of FN_T. </p></li>
<li><p><strong>GUESS_T</strong> – The type of the initial guess for the root. </p></li>
<li><p><strong>ARGS</strong> – The type of additional arguments passed to the function.</p></li>
</ul>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>func</strong> – The function for which the root is being refined. </p></li>
<li><p><strong>derivative</strong> – The derivative of the function. </p></li>
<li><p><strong>guess</strong> – The initial guess for the root. </p></li>
<li><p><strong>args</strong> – Additional arguments passed to the function.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The result of the root finding process. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4II000E0_25IsFloatOrComplexInvocable_16IsFloatOrComplexDpEN3nxx5roots8fdfsolveEDa4FN_T7GUESS_TDp4ARGS">
<span id="_CPPv3II000E0_25IsFloatOrComplexInvocable_16IsFloatOrComplexDpEN3nxx5roots8fdfsolveE4FN_T7GUESS_TDp4ARGS"></span><span id="_CPPv2II000E0_25IsFloatOrComplexInvocable_16IsFloatOrComplexDpEN3nxx5roots8fdfsolveE4FN_T7GUESS_TDp4ARGS"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SOLVER_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">IsFloatOrComplexInvocable</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FN_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">IsFloatOrComplex</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GUESS_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="sig-name descname"><span class="n"><span class="pre">ARGS</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="_root_polishing_8hpp_1ab3d45c08c5c2ca3bab5e2e50c77e67f5"></span><span class="kt"><span class="pre">auto</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">nxx</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">roots</span></span><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">fdfsolve</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4II000E0_25IsFloatOrComplexInvocable_16IsFloatOrComplexDpEN3nxx5roots8fdfsolveEDa4FN_T7GUESS_TDp4ARGS" title="nxx::roots::fdfsolve::FN_T"><span class="n"><span class="pre">FN_T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">func</span></span>, <a class="reference internal" href="#_CPPv4II000E0_25IsFloatOrComplexInvocable_16IsFloatOrComplexDpEN3nxx5roots8fdfsolveEDa4FN_T7GUESS_TDp4ARGS" title="nxx::roots::fdfsolve::GUESS_T"><span class="n"><span class="pre">GUESS_T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">guess</span></span>, <a class="reference internal" href="#_CPPv4II000E0_25IsFloatOrComplexInvocable_16IsFloatOrComplexDpEN3nxx5roots8fdfsolveEDa4FN_T7GUESS_TDp4ARGS" title="nxx::roots::fdfsolve::ARGS"><span class="n"><span class="pre">ARGS</span></span></a><span class="p"><span class="pre">...</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">args</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4II000E0_25IsFloatOrComplexInvocable_16IsFloatOrComplexDpEN3nxx5roots8fdfsolveEDa4FN_T7GUESS_TDp4ARGS" title="Link to this definition">#</a><br /></dt>
<dd></dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4II000E00_25IsFloatOrComplexInvocable_25IsFloatOrComplexInvocable_16IsFloatOrComplexEN3nxx5roots8fdfsolveEDa4FN_T7DERIV_T7GUESS_T">
<span id="_CPPv3II000E00_25IsFloatOrComplexInvocable_25IsFloatOrComplexInvocable_16IsFloatOrComplexEN3nxx5roots8fdfsolveE4FN_T7DERIV_T7GUESS_T"></span><span id="_CPPv2II000E00_25IsFloatOrComplexInvocable_25IsFloatOrComplexInvocable_16IsFloatOrComplexEN3nxx5roots8fdfsolveE4FN_T7DERIV_T7GUESS_T"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SOLVER_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">TOKEN_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">IsFloatOrComplexInvocable</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FN_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">IsFloatOrComplexInvocable</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">DERIV_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">IsFloatOrComplex</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GUESS_T</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="_root_polishing_8hpp_1afaedb256fd23b94f239270e84a23e327"></span><span class="kt"><span class="pre">auto</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">nxx</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">roots</span></span><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">fdfsolve</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4II000E00_25IsFloatOrComplexInvocable_25IsFloatOrComplexInvocable_16IsFloatOrComplexEN3nxx5roots8fdfsolveEDa4FN_T7DERIV_T7GUESS_T" title="nxx::roots::fdfsolve::FN_T"><span class="n"><span class="pre">FN_T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">func</span></span>, <a class="reference internal" href="#_CPPv4II000E00_25IsFloatOrComplexInvocable_25IsFloatOrComplexInvocable_16IsFloatOrComplexEN3nxx5roots8fdfsolveEDa4FN_T7DERIV_T7GUESS_T" title="nxx::roots::fdfsolve::DERIV_T"><span class="n"><span class="pre">DERIV_T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">derivative</span></span>, <a class="reference internal" href="#_CPPv4II000E00_25IsFloatOrComplexInvocable_25IsFloatOrComplexInvocable_16IsFloatOrComplexEN3nxx5roots8fdfsolveEDa4FN_T7DERIV_T7GUESS_T" title="nxx::roots::fdfsolve::GUESS_T"><span class="n"><span class="pre">GUESS_T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">guess</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4II000E00_25IsFloatOrComplexInvocable_25IsFloatOrComplexInvocable_16IsFloatOrComplexEN3nxx5roots8fdfsolveEDa4FN_T7DERIV_T7GUESS_T" title="Link to this definition">#</a><br /></dt>
<dd><p>A function template that solves a root finding problem using a specified solver and termination token. </p>
<p>This function template, <code class="docutils literal notranslate"><span class="pre">fdfsolve</span></code>, provides a generic implementation for root finding algorithms that utilize polishing solvers. It is designed to work with solvers that conform to the requirements of polishing solvers, such as having a defined <code class="docutils literal notranslate"><span class="pre">IsPolishingSolver</span></code> static member, initialization, and iteration methods. The function handles initialization, iteration, and convergence checking, returning the result along with any potential errors encountered during the solving process.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function requires the termination token to be a callable object that accepts an IterData object. </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>SOLVER_T</strong> – The template class of the solver to be used. Must be a valid polishing solver type. </p></li>
<li><p><strong>TOKEN_T</strong> – The type of the termination token. Must be a callable object that accepts an IterData object. </p></li>
<li><p><strong>FN_T</strong> – The type of the function for which the root is being refined. </p></li>
<li><p><strong>DERIV_T</strong> – The type of the derivative function of FN_T. </p></li>
<li><p><strong>GUESS_T</strong> – The type of the initial guess for the root.</p></li>
</ul>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>func</strong> – The function for which the root is being refined. </p></li>
<li><p><strong>derivative</strong> – The derivative of the function. </p></li>
<li><p><strong>guess</strong> – The initial guess for the root.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The result of the root finding process.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4II000E00_25IsFloatOrComplexInvocable_16IsFloatOrComplexEN3nxx5roots8fdfsolveEDa4FN_T7GUESS_T">
<span id="_CPPv3II000E00_25IsFloatOrComplexInvocable_16IsFloatOrComplexEN3nxx5roots8fdfsolveE4FN_T7GUESS_T"></span><span id="_CPPv2II000E00_25IsFloatOrComplexInvocable_16IsFloatOrComplexEN3nxx5roots8fdfsolveE4FN_T7GUESS_T"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SOLVER_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">TOKEN_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">IsFloatOrComplexInvocable</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FN_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">IsFloatOrComplex</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GUESS_T</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="_root_polishing_8hpp_1abb1d3507ca8a9242057e0090ad7b6438"></span><span class="kt"><span class="pre">auto</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">nxx</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">roots</span></span><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">fdfsolve</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4II000E00_25IsFloatOrComplexInvocable_16IsFloatOrComplexEN3nxx5roots8fdfsolveEDa4FN_T7GUESS_T" title="nxx::roots::fdfsolve::FN_T"><span class="n"><span class="pre">FN_T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">func</span></span>, <a class="reference internal" href="#_CPPv4II000E00_25IsFloatOrComplexInvocable_16IsFloatOrComplexEN3nxx5roots8fdfsolveEDa4FN_T7GUESS_T" title="nxx::roots::fdfsolve::GUESS_T"><span class="n"><span class="pre">GUESS_T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">guess</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4II000E00_25IsFloatOrComplexInvocable_16IsFloatOrComplexEN3nxx5roots8fdfsolveEDa4FN_T7GUESS_T" title="Link to this definition">#</a><br /></dt>
<dd></dd></dl>

</section>
<section id="search">
<h3>search<a class="headerlink" href="#search" title="Link to this heading">#</a></h3>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4II00E0_16IsFloatInvocable_13IsFloatStruct_7IsFloat_NSt8integralEEN3nxx5roots6searchEDa4FN_T8STRUCT_T8FACTOR_T6ITER_T">
<span id="_CPPv3II00E0_16IsFloatInvocable_13IsFloatStruct_7IsFloat_NSt8integralEEN3nxx5roots6searchE4FN_T8STRUCT_T8FACTOR_T6ITER_T"></span><span id="_CPPv2II00E0_16IsFloatInvocable_13IsFloatStruct_7IsFloat_NSt8integralEEN3nxx5roots6searchE4FN_T8STRUCT_T8FACTOR_T6ITER_T"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SOLVER_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">IsFloatInvocable</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FN_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">IsFloatStruct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">STRUCT_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">IsFloat</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FACTOR_T</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="n"><span class="pre">StructCommonType_t</span></span><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4II00E0_16IsFloatInvocable_13IsFloatStruct_7IsFloat_NSt8integralEEN3nxx5roots6searchEDa4FN_T8STRUCT_T8FACTOR_T6ITER_T" title="nxx::roots::search::STRUCT_T"><span class="n"><span class="pre">STRUCT_T</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">integral</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ITER_T</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="_root_searching_8hpp_1a90a0e904f80880f3835422949079c268"></span><span class="kt"><span class="pre">auto</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">nxx</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">roots</span></span><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">search</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4II00E0_16IsFloatInvocable_13IsFloatStruct_7IsFloat_NSt8integralEEN3nxx5roots6searchEDa4FN_T8STRUCT_T8FACTOR_T6ITER_T" title="nxx::roots::search::FN_T"><span class="n"><span class="pre">FN_T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">function</span></span>, <a class="reference internal" href="#_CPPv4II00E0_16IsFloatInvocable_13IsFloatStruct_7IsFloat_NSt8integralEEN3nxx5roots6searchEDa4FN_T8STRUCT_T8FACTOR_T6ITER_T" title="nxx::roots::search::STRUCT_T"><span class="n"><span class="pre">STRUCT_T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">bounds</span></span>, <a class="reference internal" href="#_CPPv4II00E0_16IsFloatInvocable_13IsFloatStruct_7IsFloat_NSt8integralEEN3nxx5roots6searchEDa4FN_T8STRUCT_T8FACTOR_T6ITER_T" title="nxx::roots::search::FACTOR_T"><span class="n"><span class="pre">FACTOR_T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">ratio</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">numbers</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">phi</span></span>, <a class="reference internal" href="#_CPPv4II00E0_16IsFloatInvocable_13IsFloatStruct_7IsFloat_NSt8integralEEN3nxx5roots6searchEDa4FN_T8STRUCT_T8FACTOR_T6ITER_T" title="nxx::roots::search::ITER_T"><span class="n"><span class="pre">ITER_T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">maxiter</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="n"><span class="pre">iterations</span></span><span class="p"><span class="pre">&lt;</span></span><span class="n"><span class="pre">StructCommonType_t</span></span><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4II00E0_16IsFloatInvocable_13IsFloatStruct_7IsFloat_NSt8integralEEN3nxx5roots6searchEDa4FN_T8STRUCT_T8FACTOR_T6ITER_T" title="nxx::roots::search::STRUCT_T"><span class="n"><span class="pre">STRUCT_T</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="p"><span class="pre">&gt;</span></span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">)</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4II00E0_16IsFloatInvocable_13IsFloatStruct_7IsFloat_NSt8integralEEN3nxx5roots6searchEDa4FN_T8STRUCT_T8FACTOR_T6ITER_T" title="Link to this definition">#</a><br /></dt>
<dd><p>Defines a high-level search function template <code class="docutils literal notranslate"><span class="pre">search</span></code> using bracketing searchers. </p>
<p>The <code class="docutils literal notranslate"><span class="pre">search</span></code> function template provides a convenient interface for performing search operations using various bracketing searcher algorithms. It abstracts the creation and configuration of the solver instance and then delegates the actual search process to <code class="docutils literal notranslate"><span class="pre">search_impl</span></code>. This function is templated to accept a solver type, the function, bounds for the search, a search factor for controlling the search process, and a maximum number of iterations. It supports different types of bracketing searchers, making it versatile for various search needs.</p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>SOLVER_T</strong> – The template class of the solver to be used. Must be a valid bracketing searcher type. </p></li>
<li><p><strong>FN_T</strong> – The type of the function for which the search is being conducted. </p></li>
<li><p><strong>STRUCT_T</strong> – The struct type holding the bounds for the search. </p></li>
<li><p><strong>FACTOR_T</strong> – The type of the search factor, defaulted based on STRUCT_T. </p></li>
<li><p><strong>ITER_T</strong> – The type of the maximum iterations count, defaulted to int. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4II00E0_16IsFloatInvocable_7IsFloat_7IsFloat_NSt8integralE_6size_tEN3nxx5roots6searchEDa4FN_TRA1N_K5ARG_T8FACTOR_T6ITER_T">
<span id="_CPPv3II00E0_16IsFloatInvocable_7IsFloat_7IsFloat_NSt8integralE_6size_tEN3nxx5roots6searchE4FN_TRA1N_K5ARG_T8FACTOR_T6ITER_T"></span><span id="_CPPv2II00E0_16IsFloatInvocable_7IsFloat_7IsFloat_NSt8integralE_6size_tEN3nxx5roots6searchE4FN_TRAN_K5ARG_T8FACTOR_T6ITER_T"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SOLVER_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">IsFloatInvocable</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FN_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">IsFloat</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ARG_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">IsFloat</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FACTOR_T</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4II00E0_16IsFloatInvocable_7IsFloat_7IsFloat_NSt8integralE_6size_tEN3nxx5roots6searchEDa4FN_TRA1N_K5ARG_T8FACTOR_T6ITER_T" title="nxx::roots::search::ARG_T"><span class="n"><span class="pre">ARG_T</span></span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">integral</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ITER_T</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">N</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="_root_searching_8hpp_1a6086a933b2f08fd2c63b61d1ab89be22"></span><span class="kt"><span class="pre">auto</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">nxx</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">roots</span></span><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">search</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4II00E0_16IsFloatInvocable_7IsFloat_7IsFloat_NSt8integralE_6size_tEN3nxx5roots6searchEDa4FN_TRA1N_K5ARG_T8FACTOR_T6ITER_T" title="nxx::roots::search::FN_T"><span class="n"><span class="pre">FN_T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">function</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4II00E0_16IsFloatInvocable_7IsFloat_7IsFloat_NSt8integralE_6size_tEN3nxx5roots6searchEDa4FN_TRA1N_K5ARG_T8FACTOR_T6ITER_T" title="nxx::roots::search::ARG_T"><span class="n"><span class="pre">ARG_T</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">bounds</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#_CPPv4II00E0_16IsFloatInvocable_7IsFloat_7IsFloat_NSt8integralE_6size_tEN3nxx5roots6searchEDa4FN_TRA1N_K5ARG_T8FACTOR_T6ITER_T" title="nxx::roots::search::N"><span class="n"><span class="pre">N</span></span></a><span class="p"><span class="pre">]</span></span>, <a class="reference internal" href="#_CPPv4II00E0_16IsFloatInvocable_7IsFloat_7IsFloat_NSt8integralE_6size_tEN3nxx5roots6searchEDa4FN_TRA1N_K5ARG_T8FACTOR_T6ITER_T" title="nxx::roots::search::FACTOR_T"><span class="n"><span class="pre">FACTOR_T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">ratio</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">numbers</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">phi</span></span>, <a class="reference internal" href="#_CPPv4II00E0_16IsFloatInvocable_7IsFloat_7IsFloat_NSt8integralE_6size_tEN3nxx5roots6searchEDa4FN_TRA1N_K5ARG_T8FACTOR_T6ITER_T" title="nxx::roots::search::ITER_T"><span class="n"><span class="pre">ITER_T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">maxiter</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="n"><span class="pre">iterations</span></span><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4II00E0_16IsFloatInvocable_7IsFloat_7IsFloat_NSt8integralE_6size_tEN3nxx5roots6searchEDa4FN_TRA1N_K5ARG_T8FACTOR_T6ITER_T" title="nxx::roots::search::ARG_T"><span class="n"><span class="pre">ARG_T</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">)</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4II00E0_16IsFloatInvocable_7IsFloat_7IsFloat_NSt8integralE_6size_tEN3nxx5roots6searchEDa4FN_TRA1N_K5ARG_T8FACTOR_T6ITER_T" title="Link to this definition">#</a><br /></dt>
<dd><p>Extends the high-level search function template <code class="docutils literal notranslate"><span class="pre">search</span></code> for initializer list bounds. </p>
<p>This version of the <code class="docutils literal notranslate"><span class="pre">search</span></code> function template allows for specifying the bounds using an initializer list. It is particularly useful when the bounds are known at compile time or for concise inline specifications. The function checks the size of the initializer list to ensure exactly two elements are provided for the bounds. It then creates a solver instance and delegates the search process to <code class="docutils literal notranslate"><span class="pre">search_impl</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>SOLVER_T</strong> – The template class of the solver to be used. Must be a valid bracketing searcher type. </p></li>
<li><p><strong>FN_T</strong> – The type of the function for which the search is being conducted. </p></li>
<li><p><strong>ARG_T</strong> – The type of the bounds and the argument to the function. </p></li>
<li><p><strong>FACTOR_T</strong> – The type of the search factor, defaulted based on ARG_T. </p></li>
<li><p><strong>ITER_T</strong> – The type of the maximum iterations count, defaulted to int. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="algorithms">
<h3>Algorithms<a class="headerlink" href="#algorithms" title="Link to this heading">#</a></h3>
<p>The following algorithms are available for use with the root-finding functions:</p>
<dl class="cpp class">
<dt class="sig sig-object cpp" id="_CPPv4I_16IsFloatInvocable_7IsFloatEN3nxx5roots9BisectionE">
<span id="_CPPv3I_16IsFloatInvocable_7IsFloatEN3nxx5roots9BisectionE"></span><span id="_CPPv2I_16IsFloatInvocable_7IsFloatEN3nxx5roots9BisectionE"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="n"><span class="pre">IsFloatInvocable</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FN</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">IsFloat</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ARG_T</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classnxx_1_1roots_1_1_bisection"></span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Bisection</span></span></span><span class="w"> </span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="k"><span class="pre">public</span></span><span class="w"> </span><span class="n"><span class="pre">nxx</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">roots</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">detail</span></span><span class="p"><span class="pre">::</span></span><a class="reference internal" href="#_CPPv4I000EN3nxx5roots6detail14BracketingBaseE" title="nxx::roots::detail::BracketingBase"><span class="n"><span class="pre">BracketingBase</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I_16IsFloatInvocable_7IsFloatEN3nxx5roots9BisectionE" title="nxx::roots::Bisection"><span class="n"><span class="pre">Bisection</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I_16IsFloatInvocable_7IsFloatEN3nxx5roots9BisectionE" title="nxx::roots::Bisection::FN"><span class="n"><span class="pre">FN</span></span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="p"><span class="pre">&gt;</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4I_16IsFloatInvocable_7IsFloatEN3nxx5roots9BisectionE" title="nxx::roots::Bisection::FN"><span class="n"><span class="pre">FN</span></span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="p"><span class="pre">&gt;</span></span><a class="headerlink" href="#_CPPv4I_16IsFloatInvocable_7IsFloatEN3nxx5roots9BisectionE" title="Link to this definition">#</a><br /></dt>
<dd><p>Defines the <a class="reference internal" href="#classnxx_1_1roots_1_1_bisection"><span class="std std-ref">Bisection</span></a> class for performing the bisection method of root bracketing. </p>
<p>The <a class="reference internal" href="#classnxx_1_1roots_1_1_bisection"><span class="std std-ref">Bisection</span></a> class template is an implementation of the classic bisection method for root finding. This method is a bracketing algorithm that repeatedly bisects an interval and then selects a subinterval in which a root must lie for further processing. It inherits from a base class that provides common functionalities for root bracketing algorithms, and adds the specific iteration logic for the bisection method. The class is templated to accept a function and an optional argument type.</p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>FN</strong> – The type of the function for which the root is being bracketed. </p></li>
<li><p><strong>ARG_T</strong> – The type of the argument to the function, defaults to double. </p></li>
</ul>
</dd>
</dl>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N3nxx5roots9BisectionclEv">
<span id="_CPPv3N3nxx5roots9BisectionclEv"></span><span id="_CPPv2N3nxx5roots9BisectionclEv"></span><span id="nxx::roots::Bisection::call-operator"></span><span class="target" id="classnxx_1_1roots_1_1_bisection_1a71373a255a4c24fc684480cf26edda9c"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="k"><span class="pre">operator</span></span><span class="o"><span class="pre">()</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3nxx5roots9BisectionclEv" title="Link to this definition">#</a><br /></dt>
<dd><p>Performs a single iteration of the bisection method. </p>
<p>&lt; Inherits constructors from BracketingBase.</p>
<p>This method updates the bounds by bisecting the current interval and choosing the subinterval where the sign of the function changes. </p>
</dd></dl>

</div>
</dd></dl>

</section>
</section>
<section id="design-and-implementation-details">
<h2>Design and Implementation Details<a class="headerlink" href="#design-and-implementation-details" title="Link to this heading">#</a></h2>
<p>The solver functions documented above should be sufficient for the vast majority of use cases. However, in some cases it may be necessary to use the solvers directly, or to create custom solvers. This section provides an overview of the design and implementation details of the solvers, and how they can be used and customized.</p>
<section id="interface">
<h3>Interface<a class="headerlink" href="#interface" title="Link to this heading">#</a></h3>
<p>Both the bracketing and polishing algorithms are implemented using the overall architecture: a base class is defined, for keeping track of internal state between iterations, and the individual algorithms inherits from the base class. However, in order to avoid virtual functions, the architecture is implemented using static polymorphism through the Curiously Recurring Template Pattern (CRTP) <a class="footnote-reference brackets" href="#id2" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.</p>
<p>The purpose of this design is that it avoids dynamic polymorphim and virtual functions, while ensuring that the solvers share a common interface. The downside of this approach is that all dependencies has to be resolved during compile-time, and it is not possible to dynamically plug in a different solver.</p>
<p>While the base classes (BracketingBase and PolishingBase, respectively) will not be called directly in client code, it is useful to know what the classes look like, as the individual solvers will inherit the interface of the base classes.</p>
<section id="bracketingbase">
<h4>BracketingBase<a class="headerlink" href="#bracketingbase" title="Link to this heading">#</a></h4>
<p>The BracketingBase class (located in the <code class="code docutils literal notranslate"><span class="pre">root::detail</span></code> namespace) look as follows:</p>
<dl class="cpp class">
<dt class="sig sig-object cpp" id="_CPPv4I000EN3nxx5roots6detail14BracketingBaseE">
<span id="_CPPv3I000EN3nxx5roots6detail14BracketingBaseE"></span><span id="_CPPv2I000EN3nxx5roots6detail14BracketingBaseE"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">DERIVED</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FUNCTION_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ARG_T</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classnxx_1_1roots_1_1detail_1_1_bracketing_base"></span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">BracketingBase</span></span></span><a class="headerlink" href="#_CPPv4I000EN3nxx5roots6detail14BracketingBaseE" title="Link to this definition">#</a><br /></dt>
<dd><p>Provides a base class template for root bracketing algorithms. </p>
<p>The <a class="reference internal" href="#classnxx_1_1roots_1_1detail_1_1_bracketing_base"><span class="std std-ref">BracketingBase</span></a> class template serves as a foundational component for algorithms that bracket roots of a given function. It encapsulates common functionalities such as storing the objective function and maintaining the current bounds around the root. This class enforces certain type constraints on the template parameters to ensure compatibility with root bracketing algorithms.</p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>DERIVED</strong> – The subclass inheriting from <a class="reference internal" href="#classnxx_1_1roots_1_1detail_1_1_bracketing_base"><span class="std std-ref">BracketingBase</span></a>. </p></li>
<li><p><strong>FUNCTION_T</strong> – The type of the function for which the root is being bracketed. </p></li>
<li><p><strong>ARG_T</strong> – The type of the argument to the function. </p></li>
</ul>
</dd>
</dl>
<p>Subclassed by <a class="reference internal" href="#classnxx_1_1roots_1_1_bisection"><span class="std std-ref">nxx::roots::Bisection&lt; FN, ARG_T &gt;</span></a>, nxx::roots::RegulaFalsi&lt; FN, ARG_T &gt;, nxx::roots::Ridder&lt; FN, ARG_T &gt;</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N3nxx5roots6detail14BracketingBase8evaluateE7IsFloat">
<span id="_CPPv3N3nxx5roots6detail14BracketingBase8evaluateE7IsFloat"></span><span id="_CPPv2N3nxx5roots6detail14BracketingBase8evaluateE7IsFloat"></span><span id="nxx::roots::detail::BracketingBase::evaluate__IsFloat"></span><span class="target" id="classnxx_1_1roots_1_1detail_1_1_bracketing_base_1ab49c59f46c9a8c2a4216f8a5b3315689"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">RESULT_T</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">evaluate</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">IsFloat</span></span><span class="w"> </span><span class="k"><span class="pre">auto</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3nxx5roots6detail14BracketingBase8evaluateE7IsFloat" title="Link to this definition">#</a><br /></dt>
<dd><p>Evaluates the function at a given value. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>value</strong> – The value at which the function is to be evaluated. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The result of evaluating the function at the specified value. </p>
</dd>
</dl>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-private-members">Private Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N3nxx5roots6detail14BracketingBase6m_funcE">
<span id="_CPPv3N3nxx5roots6detail14BracketingBase6m_funcE"></span><span id="_CPPv2N3nxx5roots6detail14BracketingBase6m_funcE"></span><span id="nxx::roots::detail::BracketingBase::m_func__FUNCTION_T"></span><span class="target" id="classnxx_1_1roots_1_1detail_1_1_bracketing_base_1ab5cc2e61d2db0af1f40697b55f12ad70"></span><a class="reference internal" href="#_CPPv4I000EN3nxx5roots6detail14BracketingBaseE" title="nxx::roots::detail::BracketingBase::FUNCTION_T"><span class="n"><span class="pre">FUNCTION_T</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">m_func</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N3nxx5roots6detail14BracketingBase6m_funcE" title="Link to this definition">#</a><br /></dt>
<dd><p>The function object to find the root for. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N3nxx5roots6detail14BracketingBase8m_boundsE">
<span id="_CPPv3N3nxx5roots6detail14BracketingBase8m_boundsE"></span><span id="_CPPv2N3nxx5roots6detail14BracketingBase8m_boundsE"></span><span id="nxx::roots::detail::BracketingBase::m_bounds__BOUNDS_T"></span><span class="target" id="classnxx_1_1roots_1_1detail_1_1_bracketing_base_1a8d0d0fa279e40ef159537d5159d138d2"></span><span class="n"><span class="pre">BOUNDS_T</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">m_bounds</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N3nxx5roots6detail14BracketingBase8m_boundsE" title="Link to this definition">#</a><br /></dt>
<dd><p>Holds the current bounds around the root. </p>
</dd></dl>

</div>
</dd></dl>

</section>
<section id="polishingbase">
<h4>PolishingBase<a class="headerlink" href="#polishingbase" title="Link to this heading">#</a></h4>
<p>Similarly, the PolishingBase class (located in the <code class="code docutils literal notranslate"><span class="pre">root::detail</span></code> namespace) look as follows:</p>
<dl class="cpp class">
<dt class="sig sig-object cpp" id="_CPPv4I0000EN3nxx5roots6detail13PolishingBaseE">
<span id="_CPPv3I0000EN3nxx5roots6detail13PolishingBaseE"></span><span id="_CPPv2I0000EN3nxx5roots6detail13PolishingBaseE"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SUBCLASS</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FUNCTION_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">DERIV_T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ARG_T</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classnxx_1_1roots_1_1detail_1_1_polishing_base"></span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PolishingBase</span></span></span><a class="headerlink" href="#_CPPv4I0000EN3nxx5roots6detail13PolishingBaseE" title="Link to this definition">#</a><br /></dt>
<dd><p>Provides a base class template for root polishing algorithms. </p>
<p>The <a class="reference internal" href="#classnxx_1_1roots_1_1detail_1_1_polishing_base"><span class="std std-ref">PolishingBase</span></a> class template serves as a foundational component for algorithms that refine or ‘polish’ roots of a given function. It encapsulates common functionalities such as storing the objective function, its derivative, and the current guess of the root. This class enforces certain type constraints on the template parameters to ensure compatibility with root polishing algorithms.</p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>SUBCLASS</strong> – The subclass inheriting from <a class="reference internal" href="#classnxx_1_1roots_1_1detail_1_1_polishing_base"><span class="std std-ref">PolishingBase</span></a>. </p></li>
<li><p><strong>FUNCTION_T</strong> – The type of the function for which the root is being polished. </p></li>
<li><p><strong>DERIV_T</strong> – The type of the derivative function of FUNCTION_T. </p></li>
<li><p><strong>ARG_T</strong> – The type of the argument to the function and its derivative. </p></li>
</ul>
</dd>
</dl>
<p>Subclassed by nxx::roots::Newton&lt; FN, DFN, ARG_T &gt;, nxx::roots::Secant&lt; FN, DFN, ARG_T &gt;, nxx::roots::Steffensen&lt; FN, DFN, ARG_T &gt;</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I0EN3nxx5roots6detail13PolishingBase8evaluateEDa1T">
<span id="_CPPv3I0EN3nxx5roots6detail13PolishingBase8evaluateE1T"></span><span id="_CPPv2I0EN3nxx5roots6detail13PolishingBase8evaluateE1T"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classnxx_1_1roots_1_1detail_1_1_polishing_base_1a7db612228ea82f8ef1697e1d36cfe993"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">auto</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">evaluate</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I0EN3nxx5roots6detail13PolishingBase8evaluateEDa1T" title="nxx::roots::detail::PolishingBase::evaluate::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN3nxx5roots6detail13PolishingBase8evaluateEDa1T" title="Link to this definition">#</a><br /></dt>
<dd><p>Evaluates the function with the given value. </p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>T</strong> – Type of the value, must be a float or complex type. </p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>value</strong> – The value to evaluate the function at. </p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The result of the function evaluation. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I0EN3nxx5roots6detail13PolishingBase10derivativeEDa1T">
<span id="_CPPv3I0EN3nxx5roots6detail13PolishingBase10derivativeE1T"></span><span id="_CPPv2I0EN3nxx5roots6detail13PolishingBase10derivativeE1T"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classnxx_1_1roots_1_1detail_1_1_polishing_base_1a12f0c735f5a95a474d037277453da537"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">auto</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">derivative</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I0EN3nxx5roots6detail13PolishingBase10derivativeEDa1T" title="nxx::roots::detail::PolishingBase::derivative::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN3nxx5roots6detail13PolishingBase10derivativeEDa1T" title="Link to this definition">#</a><br /></dt>
<dd><p>Evaluates the derivative function with the given value. </p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>T</strong> – Type of the value, must be a float or complex type. </p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>value</strong> – The value to evaluate the derivative at. </p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The result of the derivative function evaluation. </p>
</dd>
</dl>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-private-members">Private Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N3nxx5roots6detail13PolishingBase6m_funcE">
<span id="_CPPv3N3nxx5roots6detail13PolishingBase6m_funcE"></span><span id="_CPPv2N3nxx5roots6detail13PolishingBase6m_funcE"></span><span id="nxx::roots::detail::PolishingBase::m_func__FUNCTION_T"></span><span class="target" id="classnxx_1_1roots_1_1detail_1_1_polishing_base_1a34355239ce380e94a5c4e45b32040be4"></span><a class="reference internal" href="#_CPPv4I0000EN3nxx5roots6detail13PolishingBaseE" title="nxx::roots::detail::PolishingBase::FUNCTION_T"><span class="n"><span class="pre">FUNCTION_T</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">m_func</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N3nxx5roots6detail13PolishingBase6m_funcE" title="Link to this definition">#</a><br /></dt>
<dd><p>The function object to find the root for. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N3nxx5roots6detail13PolishingBase7m_derivE">
<span id="_CPPv3N3nxx5roots6detail13PolishingBase7m_derivE"></span><span id="_CPPv2N3nxx5roots6detail13PolishingBase7m_derivE"></span><span id="nxx::roots::detail::PolishingBase::m_deriv__DERIV_T"></span><span class="target" id="classnxx_1_1roots_1_1detail_1_1_polishing_base_1aa08563a5142bd82352411db3bd141aeb"></span><a class="reference internal" href="#_CPPv4I0000EN3nxx5roots6detail13PolishingBaseE" title="nxx::roots::detail::PolishingBase::DERIV_T"><span class="n"><span class="pre">DERIV_T</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">m_deriv</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N3nxx5roots6detail13PolishingBase7m_derivE" title="Link to this definition">#</a><br /></dt>
<dd><p>The function object for the derivative. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N3nxx5roots6detail13PolishingBase7m_guessE">
<span id="_CPPv3N3nxx5roots6detail13PolishingBase7m_guessE"></span><span id="_CPPv2N3nxx5roots6detail13PolishingBase7m_guessE"></span><span id="nxx::roots::detail::PolishingBase::m_guess__RESULT_T"></span><span class="target" id="classnxx_1_1roots_1_1detail_1_1_polishing_base_1a3422f0795e8b9faf52d19c29a649d356"></span><span class="n"><span class="pre">RESULT_T</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">m_guess</span></span></span><a class="headerlink" href="#_CPPv4N3nxx5roots6detail13PolishingBase7m_guessE" title="Link to this definition">#</a><br /></dt>
<dd><p>The current root estimate. </p>
</dd></dl>

</div>
</dd></dl>

</section>
</section>
<section id="implementation">
<h3>Implementation<a class="headerlink" href="#implementation" title="Link to this heading">#</a></h3>
<p>The implementation of the solvers is based on the algorithms described in the previous sections. The solvers are implemented as classes, with the individual algorithms being implemented through the function call operator (<code class="code docutils literal notranslate"><span class="pre">operator()</span></code>). This makes the implementation reasonably straightforward and easy to understand.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id2" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Vandevoorde, D., Josuttis, N., Gregor, D. (2018). C++ Templates - The Complete Guide</p>
</aside>
</aside>
</section>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          <a class="prev-page" href="docDerivative.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Numerical Derivatives</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, KinetiQ.dev
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">One-Dimensional Root-Finding</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#important-considerations">Important Considerations</a></li>
<li><a class="reference internal" href="#quick-start">Quick Start</a></li>
<li><a class="reference internal" href="#advanced-usage">Advanced Usage</a><ul>
<li><a class="reference internal" href="#customizing-the-solvers">Customizing the Solvers</a></li>
<li><a class="reference internal" href="#customizing-the-output">Customizing the Output</a></li>
</ul>
</li>
<li><a class="reference internal" href="#api-reference">API Reference</a><ul>
<li><a class="reference internal" href="#fsolve">fsolve</a><ul>
<li><a class="reference internal" href="#_CPPv4II00E0_25IsFloatOrComplexInvocable_13IsFloatStructDpEN3nxx5roots6fsolveEDa4FN_T8STRUCT_TDp4ARGS"><code class="docutils literal notranslate"><span class="pre">fsolve()</span></code></a></li>
<li><a class="reference internal" href="#_CPPv4II00E00_25IsFloatOrComplexInvocable_13IsFloatStructEN3nxx5roots6fsolveEDa4FN_T8STRUCT_T"><code class="docutils literal notranslate"><span class="pre">fsolve()</span></code></a></li>
<li><a class="reference internal" href="#_CPPv4II00E0_25IsFloatOrComplexInvocable_7IsFloat_6size_tDpEN3nxx5roots6fsolveEDa4FN_TRA1N_K5ARG_TDp4ARGS"><code class="docutils literal notranslate"><span class="pre">fsolve()</span></code></a></li>
<li><a class="reference internal" href="#_CPPv4II00E00_25IsFloatOrComplexInvocable_7IsFloat_6size_tEN3nxx5roots6fsolveEDa4FN_TRA1N_K5ARG_T"><code class="docutils literal notranslate"><span class="pre">fsolve()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#fdfsolve">fdfsolve</a><ul>
<li><a class="reference internal" href="#_CPPv4II000E0_25IsFloatOrComplexInvocable_25IsFloatOrComplexInvocable_16IsFloatOrComplexDpEN3nxx5roots8fdfsolveEDa4FN_T7DERIV_T7GUESS_TDp4ARGS"><code class="docutils literal notranslate"><span class="pre">fdfsolve()</span></code></a></li>
<li><a class="reference internal" href="#_CPPv4II000E0_25IsFloatOrComplexInvocable_16IsFloatOrComplexDpEN3nxx5roots8fdfsolveEDa4FN_T7GUESS_TDp4ARGS"><code class="docutils literal notranslate"><span class="pre">fdfsolve()</span></code></a></li>
<li><a class="reference internal" href="#_CPPv4II000E00_25IsFloatOrComplexInvocable_25IsFloatOrComplexInvocable_16IsFloatOrComplexEN3nxx5roots8fdfsolveEDa4FN_T7DERIV_T7GUESS_T"><code class="docutils literal notranslate"><span class="pre">fdfsolve()</span></code></a></li>
<li><a class="reference internal" href="#_CPPv4II000E00_25IsFloatOrComplexInvocable_16IsFloatOrComplexEN3nxx5roots8fdfsolveEDa4FN_T7GUESS_T"><code class="docutils literal notranslate"><span class="pre">fdfsolve()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#search">search</a><ul>
<li><a class="reference internal" href="#_CPPv4II00E0_16IsFloatInvocable_13IsFloatStruct_7IsFloat_NSt8integralEEN3nxx5roots6searchEDa4FN_T8STRUCT_T8FACTOR_T6ITER_T"><code class="docutils literal notranslate"><span class="pre">search()</span></code></a></li>
<li><a class="reference internal" href="#_CPPv4II00E0_16IsFloatInvocable_7IsFloat_7IsFloat_NSt8integralE_6size_tEN3nxx5roots6searchEDa4FN_TRA1N_K5ARG_T8FACTOR_T6ITER_T"><code class="docutils literal notranslate"><span class="pre">search()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#algorithms">Algorithms</a><ul>
<li><a class="reference internal" href="#_CPPv4I_16IsFloatInvocable_7IsFloatEN3nxx5roots9BisectionE"><code class="docutils literal notranslate"><span class="pre">Bisection</span></code></a><ul>
<li><a class="reference internal" href="#_CPPv4N3nxx5roots9BisectionclEv"><code class="docutils literal notranslate"><span class="pre">Bisection::operator()()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#design-and-implementation-details">Design and Implementation Details</a><ul>
<li><a class="reference internal" href="#interface">Interface</a><ul>
<li><a class="reference internal" href="#bracketingbase">BracketingBase</a><ul>
<li><a class="reference internal" href="#_CPPv4I000EN3nxx5roots6detail14BracketingBaseE"><code class="docutils literal notranslate"><span class="pre">BracketingBase</span></code></a><ul>
<li><a class="reference internal" href="#_CPPv4N3nxx5roots6detail14BracketingBase8evaluateE7IsFloat"><code class="docutils literal notranslate"><span class="pre">BracketingBase::evaluate()</span></code></a></li>
<li><a class="reference internal" href="#_CPPv4N3nxx5roots6detail14BracketingBase6m_funcE"><code class="docutils literal notranslate"><span class="pre">BracketingBase::m_func</span></code></a></li>
<li><a class="reference internal" href="#_CPPv4N3nxx5roots6detail14BracketingBase8m_boundsE"><code class="docutils literal notranslate"><span class="pre">BracketingBase::m_bounds</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#polishingbase">PolishingBase</a><ul>
<li><a class="reference internal" href="#_CPPv4I0000EN3nxx5roots6detail13PolishingBaseE"><code class="docutils literal notranslate"><span class="pre">PolishingBase</span></code></a><ul>
<li><a class="reference internal" href="#_CPPv4I0EN3nxx5roots6detail13PolishingBase8evaluateEDa1T"><code class="docutils literal notranslate"><span class="pre">PolishingBase::evaluate()</span></code></a></li>
<li><a class="reference internal" href="#_CPPv4I0EN3nxx5roots6detail13PolishingBase10derivativeEDa1T"><code class="docutils literal notranslate"><span class="pre">PolishingBase::derivative()</span></code></a></li>
<li><a class="reference internal" href="#_CPPv4N3nxx5roots6detail13PolishingBase6m_funcE"><code class="docutils literal notranslate"><span class="pre">PolishingBase::m_func</span></code></a></li>
<li><a class="reference internal" href="#_CPPv4N3nxx5roots6detail13PolishingBase7m_derivE"><code class="docutils literal notranslate"><span class="pre">PolishingBase::m_deriv</span></code></a></li>
<li><a class="reference internal" href="#_CPPv4N3nxx5roots6detail13PolishingBase7m_guessE"><code class="docutils literal notranslate"><span class="pre">PolishingBase::m_guess</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#implementation">Implementation</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="_static/documentation_options.js?v=d45e8c67"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/scripts/furo.js?v=32e29ea5"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </body>
</html>